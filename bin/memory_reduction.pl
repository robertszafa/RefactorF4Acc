#!/usr/bin/env perl
# 
#   (c) 2019 Wim Vanderbauwhede <Wim.Vanderbauwhede@Glasgow.ac.uk>
#   

# This script should be run in the directory with the files generated by the AutoParallelFortran compiler
use 5.010;
use warnings;
use strict;

use vars qw( $VERSION );
$VERSION = "1.2.0";
use Getopt::Std;
use File::Copy;
use Cwd;
use RefactorF4Acc::Main qw( main usage );
use Carp;
use Data::Dumper;

my %opts = ();
getopts( 'hvimst:e:w:dcC', \%opts );

if ($opts{'h'}){
    die "
    $0 -[hvstewd] 

    -v : verbose
    -s : Scalarise only, don't generate a TyTraCL main program
    -t <\$test>: Testing, no sources needed, generates ./src/ASTInstance.hs. Provide the number of the test to be run.
    -e <\$ext>: Fortran source file extension (default is .f95, needs the dot)
    -w <\$W>: warnings
    -d : debug messages
    -i : info messages 
    -c : copy the generated ASTInstance.hs to the Haskell source tree
    -C : like -c but also build and run the Haskell code and copy the generated code
    \n";
}
our $V=0;
our $W=0;
our $I=0;
our $DBG=0;
our $copy_generated_file=0;
our $gen_final = 0;
if ($opts{'c'}) {
    $copy_generated_file=1;
}
if ($opts{'C'}) {
    $copy_generated_file = 1;
    $gen_final = 1;
}

if ($opts{'v'}) {
    $V=1;
}
if ($opts{'i'}) {
    $I=1;
}
if ($opts{'d'}) {
    $DBG=1;
}
if ($opts{'w'}) {
    $W=$opts{'w'};
}
my $gen_tytra_ir_main=0;
if ($opts{'m'}) {
    $gen_tytra_ir_main=1;
}
my $scalarise=1;
my $gen_main=1;
if ($opts{'s'}) {
    $gen_main=0;
}
my $test = 0;
if ($opts{'t'}) {
    $test=$opts{'t'};
}
my $ext = '.f95';
if ($opts{'e'}) {
    $ext = $opts{'e'};
}

my $stref={};

if ($test) {
    $scalarise = 0
    #die "The -s and -t options can't be combined.\n";
}

our $kernel_sub_name='';
our $kernel_module_name='';
# First scalarise
if (!$test && $scalarise) {
    say "SCALARISE" if $V;
    my @kernel_srcs = glob("module_*_superkernel.f95"); 

    if (scalar @kernel_srcs == 1) {
        if (-d './Scalarized') {
            system ('rm -f ./Scalarized/*.f95');
        }
        my $kernel_src = shift @kernel_srcs;
        say "KERNEL MODULE SRC: $kernel_src" if $V;
        ($kernel_sub_name, $kernel_module_name) = get_kernel_and_module_names($kernel_src,'superkernel');
        if ($kernel_sub_name ne '') {
            my $rf4a_scalarize_cfg =  create_rf4a_cfg_scalarise($kernel_src,$kernel_sub_name, $kernel_module_name);  
            say "CFG: ".Dumper($rf4a_scalarize_cfg) if $V;
            my $args = {'P' => 'rename_array_accesses_to_scalars','c' => $rf4a_scalarize_cfg,
            'w'=>$W,'i'=>$I,'d'=>$DBG };
	        $stref = main($args);
        }
    } else {
        die "No kernel sources found";
    }
}


# Generate TyTraIR main routine
if ($gen_main) {
    say "GENERATING TyTraCL AST Instance for main routine" if $V;
    my @kernel_srcs = glob("module_*_superkernel.f95"); 

    if (scalar @kernel_srcs == 1 or $test) {
        if (!$test) {
            # This is currently unused
            # if (-d './TyTraC' ) {
            #     if (-e './TyTraC/kernelTop.ll')  {
            #             unlink('./TyTraC/kernelTop.ll');
            #     }
            # } else {
            #     mkdir './TyTraC';
            # }
            my $kernel_src = shift @kernel_srcs;
            say "KERNEL MODULE SRC: $kernel_src" if $V;
            ($kernel_sub_name, $kernel_module_name) = get_kernel_and_module_names($kernel_src,'superkernel');
            if ($kernel_sub_name ne '') {
                my $rf4a_tytra_hs_cfg =  create_rf4a_cfg_tytra_cl($kernel_src,$kernel_sub_name, $kernel_module_name);  
                say "CFG: ".Dumper($rf4a_tytra_hs_cfg) if $V;

    # $args is a hash with the same structure as %opts for getopts
    # $stref_init is the initial state, usually carried over from a previous pass
    # $stref_merger is a subroutine reference containing the logic to merge $stref and $stref_init
    # In this case what we need is the argument list and order from the scalarise pass
    # This is stored in $stref->{'Subroutines'}{$f}{'DeclaredOrigArgs'}
    # So I think I'll make a $stref->{'ScalarisedArgs'}{$f}

            my $args = {'P' => 'memory_reduction', 'c' => $rf4a_tytra_hs_cfg, 'o'  => './ASTInstance.hs'};
            my $stref_init=$stref;
            my $stref_merger=sub{ my ($stref, $stref_init )=@_;
                $stref->{'ScalarisedArgs'}={};
                for my $f (sort keys %{$stref_init->{'Subroutines'}}) {
                    # carp Dumper $stref_init->{'Subroutines'}{$f}{'OrigArgs'};
                        $stref->{'ScalarisedArgs'}{$f}=$stref_init->{'Subroutines'}{$f}{'DeclaredOrigArgs'};
                }
                # die;
                return $stref;
            };
	        $stref = main($args, $stref_init, $stref_merger);     
            if ($V and -e  './ASTInstance.hs') {
                system('cat ./ASTInstance.hs');
            }
            if ($copy_generated_file and -e  './ASTInstance.hs') {
                system('cp ASTInstance.hs $RF4A_DIR/TyTraCLTransformations/MemoryReduction/src');
            }
            }
        } else {
            # Tests
            if (! -d './src/') {
                die "Make sure the src subdirectory exists!\n";
            }
            my $args = {'P' => 'memory_reduction', 'c' => {'TEST'=>$test}, 'o'  => './src/ASTInstance.hs'
            ,'w'=>$W,'i'=>$I,'d'=>$DBG};
            $stref = main($args);
        }
    } else {
        die "No kernel sources found";
    }
}

if ($gen_final) {
    generate_final_F95_code($kernel_module_name,$kernel_sub_name);
}

# ==================================== AUX ====================================


sub create_rf4a_cfg_scalarise {
    my ($kernel_src,$kernel_sub_name, $kernel_module_name) = @_;    

    my $rf4a_cfg = {
'MODULE' => $kernel_module_name,
'MODULE_SRC' => $kernel_src,
'TOP' => $kernel_sub_name,
'KERNEL' =>  $kernel_sub_name,
'PREFIX' => '.',
# 'SOURCEFILES' => [],
'SRCDIRS' => ['.'],
'NEWSRCPATH' => './Scalarized',
'EXCL_SRCS' => ['(?:^(?:sub|init|param|gen_|module_\\w+_superkernel_init|\\w+_host)|\\.[^f]+$)'],
'EXCL_DIRS' => [ qw(./PostCPP ./Scalarized ./TyTraC ./MemoryReduction)],
'MACRO_SRC' => 'macros.h',
'EXT' => '.f95',
'SUB_SUFFIX' => '_scal'
};

return $rf4a_cfg;
} # END of create_rf4a_cfg_scalarise


sub create_rf4a_cfg_tytra_cl {
    my ($kernel_src,$kernel_sub_name, $kernel_module_name) = @_;    

    my $rf4a_cfg = {
'MODULE' => $kernel_module_name,
'MODULE_SRC' => $kernel_src,
'TOP' => $kernel_sub_name,
'KERNEL' => $kernel_sub_name,
'PREFIX' => '.',
'SRCDIRS' => ['.'],
# 'SOURCEFILES' => [],
'NEWSRCPATH' => './Temp',
'EXCL_SRCS' => ['(?:^(?:module_\\w+_superkernel_init|gen_|\\w+_host)|\\.[^f]+$)'],
'EXCL_DIRS' => [ qw( ./PostCPP ./Temp ./MemoryReduction ./Scalarized ./TyTraC ) ],
'MACRO_SRC' => 'macros.h',
'EXT' => '.f95'
};

    return $rf4a_cfg;
} # END of create_rf4a_cfg_tytra_cl

sub get_kernel_and_module_names {
    my ($kernel_src, $superkernel) = @_;
    
    open my $SRC, '<', $kernel_src or die $!;
    my @src_lines = <$SRC>;
    close $SRC;
    
    my @kernel_sub_names    = map {/^\s*subroutine\s+(\w+)/; $1} grep { /^\s*subroutine\s+\w+/ } @src_lines;
    my $kernel_sub_name='NO_NAME';
    if (defined $superkernel) {
            ($kernel_sub_name) = grep {/superkernel/} @kernel_sub_names;
    } else {
            ($kernel_sub_name) = grep {!/superkernel/} @kernel_sub_names;
    }
    say "KERNEL SUB NAME: <$kernel_sub_name>" if $V;
    my ($kernel_module_name) = map { /^\s*module\s+(\w+)/; $1 } grep {/^\s*module\s+\w+/} @src_lines;
    say "KERNEL MODULE NAME: <$kernel_module_name>" if $V;
    return ($kernel_sub_name, $kernel_module_name);
} # END of get_kernel_and_module_names

sub generate_final_F95_code { my ($kernel_module_name,$kernel_sub_name) = @_;
    my $hs_src_path = $ENV{RF4A_DIR}.'/TyTraCLTransformations/MemoryReduction';
    my $wd = cwd();
    chdir $hs_src_path;
    my $build_cmd_str = 'stack build' . ($V ? '' : ' --verbosity error'). ' 2>&1';
    my $build_res = `$build_cmd_str`;
    say $build_res if $V;
    die $build_res if $build_res =~/ExitFailure/s;
    my $run_cmd_str = 'stack exec' . ($V ? '' : ' --verbosity error' ). ' MemoryReduction-exe'. ' 2>&1';
    my $run_res = `$run_cmd_str`;
    say $run_res if $V;
    die $run_res if $run_res=~/MemoryReduction-exe\:/s;
    my $gen_prog_name = "gen_". substr($kernel_module_name,length( "module_"));
    my $gen_src_file_name =  "$gen_prog_name.f95";
    say $gen_src_file_name if $V;
    chdir $wd;
    if (not -d 'MemoryReduction') {
        mkdir 'MemoryReduction';
        mkdir 'MemoryReduction/Generated';
        mkdir 'MemoryReduction/Scalarized';
    }
    my @scalarised_files = glob('Scalarized/*.f95');
    my @srcs = ($gen_src_file_name);
    for my $scalarised_file (@scalarised_files){
        if (not 
            (
             $scalarised_file=~/Scalarized\/$kernel_sub_name/
             or 
                $scalarised_file=~/Scalarized\/$kernel_module_name/
            )
        ) {
            push @srcs, '../'.$scalarised_file;
            copy($scalarised_file,'MemoryReduction/Scalarized') or die "Copy of $scalarised_file failed: $!";
        }
    }

    copy( "$hs_src_path/$gen_src_file_name", 'MemoryReduction/Generated/'.$gen_src_file_name ) or die "Copy of $gen_src_file_name failed: $!";

    gen_SConstruct('./MemoryReduction/Generated/SConstruct',$gen_prog_name,\@srcs);

} # END of generate_final_F95_code

sub gen_SConstruct { my ($sconstruct_path,$prog_name,$srcs) = @_;

my $srcs_str = join(', ', map {"'".$_."'"} @{$srcs});

open my $SC,'>', $sconstruct_path or die $!;
my $sconstruct_strs = <<"ENDSC";
import os

FC=os.environ.get('FC')

fsources = [$srcs_str]

FFLAGS = ['-Wall','-cpp','-O3','-m64','-ffree-form','-ffree-line-length-0','-fconvert=little-endian','-frecord-marker=4']

envF=Environment(F95=FC,LINK=FC,F95FLAGS=FFLAGS,F95PATH=['.' ,'../Scalarized','/usr/local/include'])

envF.Program('$prog_name',fsources,LIBS=['m'],LIBPATH=['.' ,'/usr/lib','/usr/local/lib'])

ENDSC

print $SC $sconstruct_strs;

close $SC;
}



sub VERSION_MESSAGE {	
	if (join(' ',@ARGV)=~/--help/) {
		usage();
	}
	die "Version: $VERSION\n";
}
