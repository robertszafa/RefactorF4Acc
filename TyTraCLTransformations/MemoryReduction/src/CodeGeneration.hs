module CodeGeneration (
        inferSignatures,
        createStages,
        generateFortranCode
    ) where

import Data.Generics (mkQ, everything, mkM, everywhereM, everywhere, mkT)
import Control.Monad.State
import qualified Data.Map.Strict as Map
import qualified Data.Set as Set
import Data.List (foldl', intercalate, nub, partition, zip4, unzip4, maximum)
import Data.Bifunctor ( bimap, second )

import TyTraCLAST
import ASTInstance (functionSignaturesList, stencilDefinitionsList, mainArgDeclsList, origNamesList, scalarisedArgsList, superkernelName)
import Warning ( warning )

{-# ANN module "HLint: ignore Use camelCase" #-}
{-# ANN module "HLint: ignore Use lambda-case" #-}
{-# ANN module "HLint: ignore Use fromMaybe" #-}
{-# ANN module "HLint: ignore Use zipWith" #-}
{-# ANN module "HLint: ignore Redundant curry" #-}
{-# ANN module "HLint: ignore Reduce duplication" #-}

(!) :: Ord k => Map.Map k a -> k -> a
(!) = (Map.!)

-- For code generation testing
genMain = True
genModule = True -- if False, will generate the main program if genMain is True
genStages = True
withStencilRewrites = not noStencilRewrites

generateFortranCode decomposed_ast functionSignaturesList idSigList =
    let
        functionSignatures' =  Map.fromList (functionSignaturesList++idSigList)
        (asts_function_defs,ast_stages) = createStages decomposed_ast
        functionSignatures = inferSignaturesMap functionSignatures' asts_function_defs
        generatedFunctionDefs = generateDefs functionSignatures asts_function_defs
        -- (warning asts_function_defs ("AST FUNCTION DEFS:\n"++ unlines (map (\(Function f_name _,exp)-> "("++f_name++", "++(show exp)++")") asts_function_defs) ++ "\n========================\n"))
        -- generatedStageKernels = map (\(ast,ct) -> (generateStageKernel functionSignatures) ct ast) (zip ast_stages [1..])
        (mainProgramStr,(maybeMainModuleStr,maybeEndModuleStr))
            | genMain =
                let
                    (mp,(mm,mme)) = generateMainProgramOrSuperkernel genModule functionSignatures ast_stages
                in
                    (mp,(
                        -- "! AST STAGES:\n"++unlines (map (\st -> "! " ++ (show st)) ast_stages) ++"\n"++
                        mm,mme))
            | otherwise = ("! Main code not generated",("",""))

        generatedOpaqueFunctionDefsStr = unlines generatedOpaqueFunctionDefs
        -- putStrLn "\n! Generate subroutine definitions"
        generatedFunctionDefsStr = unlines generatedFunctionDefs
        -- putStrLn "\n! Generated stage kernels"
        -- generatedStageKernelsStr
        --     | genStages =  unlines generatedStageKernels         
        --     | otherwise = "! Stage kernel code not generated"
    in
        if not (null maybeMainModuleStr) then -- means we have a module
        (mainProgramStr,unlines [
             maybeMainModuleStr
            ,generatedOpaqueFunctionDefsStr
            ,generatedFunctionDefsStr
            ,maybeEndModuleStr
        ])
        else -- means this is just a program
            (unlines [
                mainProgramStr
                ,generatedOpaqueFunctionDefsStr
                ,generatedFunctionDefsStr
            ],"")

-- Create maps from the lists in ASTIntance.hs
-- This is because ASTIntance.hs is generated by RefactorF4Acc
functionSignatures :: Map.Map Name FSig
functionSignatures =  Map.fromList functionSignaturesList

mainArgDecls :: Map.Map Name FDecl
mainArgDecls =  Map.fromList mainArgDeclsList

stencilDefinitions :: Map.Map Name [Integer]
stencilDefinitions  =  Map.fromList stencilDefinitionsList

{-
("f" => 
    ("acc" => [("acc_1",Out)],
    "v" => [("v_0",In)],
    "acc" => [("acc_0",In)]
    )
)

fromList [("f",fromList [("acc",[("acc_0",In)]),("v",[("v_0",In)])])],"f","acc")

So we have a list of tuples (f, [("acc",[("acc_0",In)]),("acc",[("acc_1",Out)]) ]

So I map over that list, and I work on the second elt in the tuple, i.e. a list of tuples

But rather than doing simply fromList, I first transform that list:
-}
mergeFields lst = let
-- get the unique names:
    unique_names = nub $ map (\(n,_) -> n) lst
-- for each unique name, filter the list 
    in
        map (\un -> let
                tups_n = filter (\(n,_) -> n == un) lst
                -- [(n,l1),(n,l2)]
                n = fst $ head tups_n
                snds = map snd tups_n
                -- [l1,l2]
                snds_merged = concat snds
            in
                (n,snds_merged)
        ) unique_names


origNames :: Map.Map Name (Map.Map Name [(Name, FIntent)])
origNames = Map.fromList $ map (second (Map.fromList . mergeFields)) origNamesList

scalarisedArgs :: Map.Map Name [(Name,(Integer, FIntent, Name))]
scalarisedArgs = Map.fromList scalarisedArgsList

{-
9.4 Generating the intermediate function definitions
-}

-- For info only, not called except in Main when info = True
inferSignatures :: TyTraCLAST -> [(Name,FSig)]
inferSignatures ast = Map.toList (inferSignaturesMap functionSignatures ast)

{-
Step 1. Derive the intermediate function signatures
-}

-- We update this map with the infered signatures of intermediate functions
-- let's be old-school contrarian and use fold
inferSignaturesMap :: Map.Map Name FSig -> TyTraCLAST -> Map.Map Name FSig
inferSignaturesMap = foldl inferSignature

inferSignature ::  Map.Map Name FSig -> (Expr,Expr) -> Map.Map Name FSig
inferSignature functionSignatures ast_tup =
    let
        (lhs,rhs) = ast_tup
        (fname,mfsig) = case lhs of
            Function fname _ -> (fname,Just $ getFunctionSignature rhs functionSignatures)
            _ -> ("",Nothing)
    in
        case mfsig of
            Just fsig -> Map.insert fname fsig functionSignatures
            Nothing -> functionSignatures

getFunctionSignature :: Expr ->  Map.Map Name FSig -> FSig
getFunctionSignature rhs functionSignatures =
        case rhs of
            MapS (SVec sv_sz _ ) (Function fname _) -> deriveSigMaps sv_sz fname functionSignatures
            Comp (Function f1 _) (Function f2 _) -> deriveSigComp f1 f2 functionSignatures
            Comp (PElt idx) (Function fname _) -> deriveSigPELt idx fname functionSignatures
            Comp (PElts idxs) (Function fname _) -> deriveSigPELts idxs fname functionSignatures
            FComp (Function f1 _) (Function f2 _) -> deriveSigFComp f1 f2 functionSignatures
            ApplyT fs -> deriveSigApplyT fs functionSignatures
            _ -> error $ "Can't get function signature for "++(show rhs)

{-
maps :: SVec sz a -> c->a->b -> c->SVec sz a -> SVec sz b
-}
deriveSigMaps :: Int -> Name -> Map.Map Name FSig -> FSig
deriveSigMaps sv_sz fname functionSignatures =
    let
        fsig = functionSignatures ! fname
        os:ms:nms_maybe_accs = reverse fsig
        ms' = SVec sv_sz (updateName "sv" "in" ms)
        os' = SVec sv_sz (updateName "sv" "out" os)
    in
        reverse $ os':ms':nms_maybe_accs
        -- case fsig of
        --     [nms,ms,os] -> let
        --             ms' = SVec sv_sz (updateName "sv" "in" ms)
        --             os' = SVec sv_sz (updateName "sv" "out" os)
        --         in
        --             [nms,ms',os']
        --     [nms,as,ms,os] -> let
        --             ms' = SVec sv_sz (updateName "sv" "in" ms)
        --             os' = SVec sv_sz (updateName "sv" "out" os)
        --         in
        --             [nms,as,ms',os']    

-- comp :: (b->c) -> (a->b) -> a -> c
deriveSigComp :: Name -> Name -> Map.Map Name FSig -> FSig
deriveSigComp fname1 fname2 functionSignatures =
    let
        fsig1 =  functionSignatures ! fname1
        fsig2 =  functionSignatures ! fname2
        [nms1,_,os1] = fsig1
        [nms2,ms2,_] = fsig2
-- the output of f2 is used as the input for f1
        (nms,ms',os') = (Tuple [nms1,nms2], ms2, os1)
    in
        [nms,ms',os']
-- fcomp :: (c->b->c) -> (a->b) -> c -> a -> c
deriveSigFComp :: Name -> Name -> Map.Map Name FSig -> FSig
deriveSigFComp fname1 fname2 functionSignatures =
    let
        fsig1 =  functionSignatures ! fname1
        fsig2 =  functionSignatures ! fname2
        [nms1,as,_,os1] = fsig1
        [nms2,ms2,_] = fsig2
    -- the output of f2 is used as the input for f1
        (nms,ms',os') = (Tuple [nms1,nms2], ms2, os1)
    in
        [nms,as,ms',os']
-- elt :: (i::Int) -> (..., a_i, ...) -> a_i
deriveSigPELt :: Int -> Name -> Map.Map Name FSig -> FSig
deriveSigPELt idx fname functionSignatures =
    let
        fsig =  functionSignatures ! fname
    in
        case fsig of
            [nms,ms,os] -> let
                    Tuple es = os
                    os' = es !! idx
                in
                     [nms,ms,os']
            [nms,as,ms,os] -> let
                    Tuple es = os
                    os' = es !! idx
                in
                    [nms,as,ms,os']

-- elt :: ([i,j::Int]) -> (..., a_i, ...,a_j, ...) -> [a_i, ..., a_j, ...]
deriveSigPELts :: [Int] -> Name -> Map.Map Name FSig -> FSig
deriveSigPELts idxs fname functionSignatures =
    let
        fsig =  functionSignatures ! fname
    in
        case fsig of
            [nms,ms,os] -> let
                    Tuple es = os
                    oss' = map (\idx -> es !! idx) idxs
                in
                     [nms,ms,Tuple oss']
            [nms,as,ms,os] -> let
                    Tuple es = os
                    oss' = map (\idx -> es !! idx) idxs
                in
                    [nms,as,ms,Tuple oss']                    

-- ApplyT can only arise because of Map, so it can't be Fold.       
-- Arguments to ApplyT can be Function, Id, what else? Let's assume that is all
-- The signature of the derived function should be grouped   
-- ApplyT simply applies a number of functions to a number of elements in a tuple
-- So the signature is the combination of all signatures
deriveSigApplyT :: [Expr] -> Map.Map Name FSig -> FSig
deriveSigApplyT fs functionSignatures =
    let
        fsigs = getFSigs fs functionSignatures
        -- So we have for every function a list [Expr, Expr, Expr]
        -- I need to combine this into a single list. To do so, I have to remove the Tuple and then concat. Easy:
        (nsl, msl, osl) = unzip3 $ map (\[nm,m,o] -> (nm,m,o)) fsigs
        (ns, ms, os) = (Tuple nsl,Tuple msl,Tuple osl)
    in
        [ns,ms,os]

-- ----------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------

{-
Step 2. Generate Fortran definitions for the non-function expressions
This means stencils, map and fold calls, vector and tuple assignments
-}
-- A tuple, fst elt is a list of declarations, snd elt is a list of statements
-- The statements can only be Stencil, Map or Fold
generateNonSubDefs :: Map.Map Name FSig -> TyTraCLAST -> ([FDecl],[String],[String],(Integer,Integer))
generateNonSubDefs functionSignatures ast =
    let
        (stmts, decl_lines,decls,lbs) = foldl (
            \(lst,st,ds,lbs) elt ->  let
                (elt',st',ds',lbs') = generateNonSubDef functionSignatures elt
            in
                (lst++[elt'],st++st',ds++ds',update_lbs lbs lbs')
                ) ([],[],[],(0,0)) ast
        unique_decl_lines = nub decl_lines
        unique_decls = nub decls
        update_lbs lbs1 lbs2 = let
                (lb1,ub1) = lbs1
                (lb2,ub2) = lbs2
            in
                (min lb1 lb2,max ub1 ub2)
    in
        (unique_decls, unique_decl_lines, stmts, lbs)

-- Returns a string with the statement and a list of decl strings
generateNonSubDef :: Map.Map Name FSig -> (Expr, Expr) -> (String,[String],[FDecl],(Integer,Integer))
generateNonSubDef functionSignatures t  =
    let
        (lhs,rhs) = t
        lhs' = mkFinalVecs lhs
        v_name = getName lhs'
        in
        case rhs of
            Stencil s_exp v_exp -> generateStencilAppl s_exp v_exp v_name stencilDefinitions
            rhs' -> let
                    (str,strs,decls) = case rhs' of
                        Map f_exp v_exp -> generateMap functionSignatures f_exp v_exp t
                        UnzipT (Map f_exp v_exp) -> generateMap functionSignatures f_exp v_exp t
                        Vec _ Scalar {} -> generateVecAssign lhs rhs
                        Elt _ vec@(Vec _ Scalar {}) -> generateVecAssign lhs vec -- FIXME
                        Fold f_exp acc_exp v_exp -> generateFold functionSignatures f_exp acc_exp v_exp t
                        _ -> error $ show t -- (show rhs, ["generateNonSubDef: TODO: "++(show t)])
                in
                    (str,strs,decls,(0,0))
            --TODO: unhandled case: 
            -- Elt idx vec@(Vec _ (Scalar {}))
-- ----------------------------------------------------------------------------------------
-- ---------------------------------------------------------------------------------------- 
{-
Step 3. Generate the Fortran definitions for the intermediate functions
-}

-- ----------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------        


-- Step 3a. Generate Fortran definitions for the opaque functions
-- These are wrappers which call the original scalarised kernels -- TODO!!!

-- This is fine as we don't need opaques for the Ids
opaqueFunctionExprs = map (\(fname, _) -> (Function fname [], Id fname [] )) functionSignaturesList
generatedOpaqueFunctionDefs = map (\elt -> fst $ generateSubDef functionSignatures [] elt []) opaqueFunctionExprs 

generateDefs :: Map.Map Name FSig -> TyTraCLAST -> [String] -- 
generateDefs  functionSignatures ast = let
        (applyt_defs_str,_,functionSignatures') = foldl (
                \(lst,st,functionSignatures_) elt ->  let
                    (elt',st',functionSignatures__) = generateSubDefApplyT' functionSignatures_ ast elt st
                in
                    (lst++[elt'],st',functionSignatures__)
                    ) ([],[],functionSignatures) ast
        other_defs_str = fst $ foldl (
            \(lst,st) elt ->  let
                (elt',st') = generateSubDef functionSignatures' ast elt st
            in
                (lst++[elt'],st')
                ) ([],[]) ast                                                
    in 
        applyt_defs_str ++ ["\n"] ++ other_defs_str


-- A table of signatures, a (lhs,rhs) expression tuple, and a list of strings apparently unused. 
generateSubDefApplyT' :: Map.Map Name FSig -> TyTraCLAST -> (Expr, Expr) -> [String] -> (String,[String],Map.Map Name FSig)
generateSubDefApplyT' functionSignatures ast t st =
    let
        (lhs,rhs) = t
        Function ho_fname _ = lhs
    in
        case rhs of
            ApplyT f_exps -> generateSubDefApplyT f_exps ho_fname functionSignatures ast
            _ -> (show rhs ,[], functionSignatures)

-- A table of signatures, a (lhs,rhs) expression tuple, and a list of strings apparently unused. 
generateSubDef :: Map.Map Name FSig -> TyTraCLAST -> (Expr, Expr) -> [String] -> (String,[String])
generateSubDef functionSignatures ast t st =
    let
        (lhs,rhs) = t
        Function ho_fname _ = lhs
    in
        (case rhs of
            MapS sv_exp f_exp -> generateSubDefMapS sv_exp f_exp ho_fname functionSignatures ast
            -- ApplyT f_exps -> generateSubDefApplyT f_exps ho_fname functionSignatures ast
            Comp (PElt idx) f_exp -> generateSubDefElt idx f_exp ho_fname functionSignatures 
            Comp (PElts idxs) f_exp -> generateSubDefElts idxs f_exp ho_fname functionSignatures ast
            Comp f1_exp f2_exp -> generateSubDefComp f1_exp f2_exp ho_fname functionSignatures ast
            FComp f1_exp f2_exp -> generateSubDefFComp f1_exp f2_exp ho_fname functionSignatures 
            Id _ _ -> generateSubDefOpaque ho_fname functionSignatures 
            _ -> show rhs
            ,[])

createCallArg :: Name -> Name -> Integer -> Name
createCallArg fname orig_name stencil_index =
    let
        actual_arg_name = if not (null ( (origNames ! fname) ! orig_name))
            then
                fst $ head ( origNames ! fname ! orig_name)
            else
                error $ show (origNames ! fname) ++ "; "++ orig_name
    in
        actual_arg_name ++ (if stencil_index==0 then "" else "("++show stencil_index++")")


-- -- To be used instead of createCallArg in generateSubDefOpaque
-- createCallArgFromArgRec :: Name -> (Name,(Integer,FIntent,FType)) -> Name
-- createCallArgFromArgRec fname arg_rec@(orig_name, (stencil_index, intent, ftype)) =
--     if not (null ( (origNames ! fname) ! orig_name))
--         then case intent of
--             Out ->    let
--                     scal_args = origNames ! fname ! orig_name
--                     out_scal_args = filter (\(_, intent) -> intent == Out) scal_args;
--                     out_scal_arg = fst $ head out_scal_args
--                 in
--                     out_scal_arg
--             InOut -> handleInOutArg fname orig_name ftype stencil_index
--             In -> 
--                 let
--                     scal_args = origNames ! fname ! orig_name
--                     in_scal_args = filter (\(_, intent) -> intent == In) scal_args;
--                     in_scal_arg = fst $ head out_scal_args
--                 in
--                     in_scal_arg ++ (if stencil_index==0 then "" else "("++show stencil_index++")")
--         else
--             error $ show (origNames ! fname) ++ "; "++ orig_name


handleInOutArg fname orig_name ftype stencil_index = let
    actual_arg_names = origNames ! fname ! orig_name
    actual_in_arg_name = if any (\(n,i) -> i==In) actual_arg_names
        then
            Just $ fst $ head $ filter (\(n,i) -> i==In) actual_arg_names
        else
            -- means that, although the intent in scalarisedArgs is InOut,
            -- the intent in origNames is only Out
            Nothing
            -- error $ show actual_arg_names  

    -- actual_out_arg_name = fst $ head $ filter (\(n,i) -> i==Out) actual_arg_names
    actual_out_arg_name = if any (\(n,i) -> i==Out) actual_arg_names
        then
            Just $ fst $ head $ filter (\(n,i) -> i==Out) actual_arg_names
        else
            -- means that, although the intent in scalarisedArgs is InOut,
            -- the intent in origNames is only In
            -- error $ show actual_arg_names    
            Nothing
    -- The args are per definition scalar and we only need this for temporary variables
    orig_arg_decl_str =  "    "++ftype++" :: "++orig_name
    pre_call_assignment_str = case actual_in_arg_name of
        Just actual_in_arg_name -> "    "++orig_name++" = "++actual_in_arg_name++ (if stencil_index==0 then "" else "("++show stencil_index++")")
        Nothing -> ""
    post_call_assignment_str = case actual_out_arg_name of
        Just actual_out_arg_name -> "    "++actual_out_arg_name++" = "++orig_name
        Nothing -> ""
    in
        -- error $ show 
        (orig_arg_decl_str,pre_call_assignment_str,post_call_assignment_str)
        -- error $ show(origNamesList,origNames, fname, orig_name)

generateSubDefOpaque fname functionSignatures =
    let
        fsig = functionSignatures ! fname
        -- Then for every f we do:
        opaque_function_code_strs = if null scalarisedArgsList
            then
                []
            else
                let
                    argsList = scalarisedArgs ! fname
                    (mappedArgsList, extra_statements) = unzip $ map (
                            \arg_rec@(orig_name, (stencil_index, intent, ftype)) ->
                                case intent of
                                    InOut -> let
                                                extra_statements = handleInOutArg fname orig_name ftype stencil_index
                                        in
                                            -- we need to use the orig_name instead of the new name!
                                            -- createCallArg fname  stencil_index
                                            (orig_name, extra_statements)
                                    Out -> let
                                                scal_args = origNames ! fname ! orig_name
                                                out_scal_args = filter (\(_, intent) -> intent == Out) scal_args;
                                                out_scal_arg = fst $ head out_scal_args
                                            in
                                                (out_scal_arg,("","",""))
                                    In ->  (createCallArg fname orig_name stencil_index,("","",""))
                                    _ -> error $ "Unknown Intent: "++ show intent ++" for orig_name in fname"
                        ) argsList
                    (orig_arg_decl_strs,pre_call_assignment_strs,post_call_assignment_strs) = unzip3 extra_statements
                    mappedArgsListStr = commaSepList mappedArgsList
                    -- WV 2021-07-16 What I should do instead is substitute the args in mappedArgsList with the LHS of post_call_assignment_strs
                    -- So I should generate a hash from post_call_assignment_strs                    
                in
                    [
                    "    ! Temp vars"
                    , unlines $ filter (/="") orig_arg_decl_strs
                    ,"    ! Call to the original scalarised subroutine"
                    , unlines $ filter (/="") pre_call_assignment_strs -- WV 2021-05-20 FIXME: this is empty for Fold
                    ,"    call "++fname++"_scal("++mappedArgsListStr++")"
                    , unlines $ filter (/="") post_call_assignment_strs -- WV 2021-05-20 FIXME: this is incorrect for Fold, has acc_0 instead of acc_1
                    ]

        in
            case fsig of
                [nms,ms,os] ->
                    let
                        non_map_arg_decls = map show $ createIODecls (Just In) nms -- tuple becomes list of decls
                        in_arg_decls = map show $ createIODecls (Just In)  ms
                        out_arg_decls = map show $ createIODecls (Just Out) os
                        non_map_args = getVarNames nms
                        in_args = getVarNames ms
                        out_args = getVarNames os
                        -- use_statements_for_opaques = map (\fname -> "    use singleton_module_"++fname++", only : "++fname++"_scal") (Map.keys scalarisedArgs)
                    in
                        buildSubDef ""
                            fname
                            [non_map_args,in_args,out_args]
                            [non_map_arg_decls,in_arg_decls,out_arg_decls]
                            opaque_function_code_strs
                            True
                        -- unlines $ [
                        --      "subroutine "++fname++"("  ++mkArgList [non_map_args,in_args,out_args]++")"
                        --  ] ++ use_statements_for_opaques ++
                        --      [mkDeclLines [non_map_arg_decls,in_arg_decls,out_arg_decls]]
                        --  ++
                        -- opaque_function_code_strs
                        -- ++ [
                        --     "end subroutine "++fname
                        -- ]
                [nms,as,ms,os] ->
                    let
                        non_map_arg_decls = map show $ createIODecls (Just In) nms -- tuple becomes list of decls
                        acc_arg_decls = map show $ createIODecls (Just In) as
                        in_arg_decls = map show $ createIODecls (Just In) ms
                        out_arg_decls = map show $ createIODecls (Just Out) os
                        non_map_args = getVarNames nms
                        acc_args  = getVarNames as
                        in_args = getVarNames ms
                        out_args = getVarNames os
                    in
                        buildSubDef ""
                            fname
                            [non_map_args,acc_args,in_args,out_args]
                            [non_map_arg_decls,acc_arg_decls,in_arg_decls,out_arg_decls]
                            opaque_function_code_strs
                            True
                        -- -- error $ "TODO:" ++
                        -- unlines ( [
                        --      "subroutine "++fname++"("  ++mkArgList [non_map_args,acc_args,in_args,out_args]++")"
                        --     , mkDeclLines [non_map_arg_decls,acc_arg_decls,in_arg_decls,out_arg_decls]
                        --     ] ++
                        --     opaque_function_code_strs
                        --     ++ [
                        --     "end subroutine "++fname
                        --     ])

generateSubDefMapS :: Expr -> Expr -> Name -> Map.Map Name FSig -> TyTraCLAST -> String
generateSubDefMapS sv_exp f_exp maps_fname functionSignatures ast =
    let
        SVec sv_sz _ = sv_exp
        Function fname _ = f_exp

        maps_fsig = functionSignatures ! maps_fname

        (argts_fn,arg_decls,arg_names) = createArgDeclsAndNames maps_fsig
        [_,in_argtfn, out_argtfn] = argts_fn
        [non_map_arg_decls,sv_in_decl,sv_out_decl] = arg_decls
        [non_map_args,sv_in,sv_out] = arg_names

        sv_in_iters = createIter in_argtfn
        sv_out_iters = createIter out_argtfn
        sv_in_accesses = zipWith (++) sv_in sv_in_iters -- curry (\(x,y)-> x++y)
        sv_out_accesses = zipWith (++) sv_out sv_out_iters -- curry (\(x,y)-> x++y)
    in
        buildSubDef ""
            maps_fname
            [non_map_args,sv_in,sv_out]
            [non_map_arg_decls,sv_in_decl,sv_out_decl]
            [
                 "    integer :: i"
                ,"    do i=1,"++ show sv_sz
                ,"        call "++fname++"("++
                mkArgList [non_map_args,sv_in_accesses,sv_out_accesses]
                ++")"
                ,"    end do"
            ]
            False

{-
We can further reduce the number of calls in ApplyT:

- We look for all f_maps calls containing f_pelts calls and all f_pelts calls 
- Anything else we can't do anything about
- If they have common inputs we look further, else we give up
- For f_pelts with common f, i.e. (Comp (PElts ...) f), we can merge them further, otherwise we give up

* f_exps is a list of RHS expression that make up the args of the ApplyT call
* applyt_fname is the LHS name of the function doing the ApplyT
* functionSignatures is the table where we get the signature for this function

As I only want to change the internals, the sig should not change.

The problem here is that at this stage, we don't have (Comp (PElts ...) f), we have (Function fname ...)
So I need to have a lookup from this function name to the body. So I added the function definitions AST to the args
-}
groupPEltsCallsInApplyT :: [Expr] -> [(Expr,Expr)] -> Map.Map Expr Expr
groupPEltsCallsInApplyT f_exps ast = let
-- We first make a list of all the Function exps, by filtering f_exps

    proper_fs = filter (\exp -> case exp of 
            Function fname _ -> True
            _ -> False
        ) f_exps

-- Then we get all the corresponding definitions from the ast:

    f_defs = filter (\(f_exp, _) -> f_exp `elem` proper_fs) ast

-- Now we look at which of these f_defs have PElts
-- We need the list of all comp_pelts from the AST:
    f_defs_comp_pelts_in_ast = filter (\(_, f_def) -> case f_def of
        Comp (PElts idxs) f -> True
        _ -> False
        ) ast

-- Comp Pelt calls in ApplyT are straightforward
    f_defs_comp_pelts_in_applyt = filter (\(_, f_def) -> case f_def of
        Comp (PElts idx) f -> True
        _ -> False
        ) f_defs

-- The MapS calls have functions so this is a two-step process
    f_defs_maps_in_applyt = filter (\(_, f_def) -> case f_def of
        -- If the function is in the comp_pelts list, we want it
        MapS (SVec k _) f_exp -> f_exp `elem` (map fst f_defs_comp_pelts_in_ast)
        _ -> False
        ) f_defs

-- Now we have all Comp PElts _ and MapS _ Comp Pelts _
    
-- For f_pelts with common f, i.e. (Comp (PElts ...) f), we can merge them further
-- So now we need to see which of these have a common f. We do this by taking the first one, put it in one map, and then any next one we put in another map
-- We do this first for f_defs_comp_pelts_in_applyt. This is [(f_name, f_def)] and f_def is (Comp (PElts _) f)
-- So we say enter f_name_1 => f_pelts_name_1  in the map
-- then for f_pelts_name_2 we get its f, say f_name_2. If that exists in the map, we enter f_pelts_name_2 in the other map: f_pelts_name_2 => f_pelts_name_1
-- otherwise we enter f_name_2 => f_pelts_name_2 in the first map
{-
If I could make the simplifying assumption that there can never be 
(MapS (SVec k _) Comp (PElt i) f)  and Comp (PElt j) f 
in the same ApplyT that would simplify matters but I don't think I can.
The namesToUniqueNames maps can be merged without a problem. But I think it is possible that we have f => maps ... and f => comp pelt ... for a given f.
The question is if I still need the uniqueNamesForExprs. Once I have the names of the functions that are OK to be merged, that should be enough.
So let's just return the merged namesToUniqueNames map
-}
    (uniqueNamesForExprs_pelts,namesToUniqueNames_pelts) = indentifyGroupableFunctions f_defs_comp_pelts_in_applyt
    (uniqueNamesForExprs_maps,namesToUniqueNames_maps) = indentifyGroupableFunctions f_defs_maps_in_applyt
    in 
        -- error "Placeholder"
        Map.union namesToUniqueNames_pelts namesToUniqueNames_maps

-- So now we have a Map which tells us which of the called functions can be merged. The final step is to actually merge them. What does this take?


{-
We need to see which of these have a common f. We do this by taking the first one, put it in one map, and then any next one we put in another map
We do this first for f_defs_comp_pelts_in_applyt. This is [(f_name, f_def)] and f_def is (Comp (PElts _) f)
So we say enter f_name_1 => f_pelts_name_1  in the map uniqueNamesForExprs
     (uniqueNamesForExprs, namesToUniqueNames) = foldl' (\(uniqueNamesForExprs_,namesToUniqueNames_) (lhsExpr,rhsExpr) ->
then for f_pelts_name_2 we get its f, say f_name_2. If that exists in the map, we enter f_pelts_name_2 in the other map namesToUniqueNames: f_pelts_name_2 => f_pelts_name_1
otherwise we enter f_name_2 => f_pelts_name_2 in the first map
-}
indentifyGroupableFunctions :: [(Expr,Expr)] -> (Map.Map Expr Expr, Map.Map Expr Expr)
indentifyGroupableFunctions ast = let
        (uniqueNamesForExprs, namesToUniqueNames) = foldl' (\(uniqueNamesForExprs_,namesToUniqueNames_) (lhsExpr,rhsExpr) ->
            if Map.member (opaqueFunctionName rhsExpr) uniqueNamesForExprs_
                then 
                    -- There is already an entry for this rhsExp, so skip this line
                    (uniqueNamesForExprs_, Map.insert lhsExpr (uniqueNamesForExprs_ ! opaqueFunctionName rhsExpr) namesToUniqueNames_) -- 
                else 
                    -- This line is unique, add to the AST
                    (Map.insert (opaqueFunctionName rhsExpr) lhsExpr uniqueNamesForExprs_,namesToUniqueNames_) -- 

            ) (Map.empty,Map.empty) ast
    in
        -- error $ show (uniqueNamesForExprs, namesToUniqueNames)
        (uniqueNamesForExprs, namesToUniqueNames)

-- Note that this returns (Function Name [Expr]), not Name
-- This assumes there are no more PElt calls, only PElts
opaqueFunctionName :: Expr -> Expr
opaqueFunctionName (Comp (PElts idxs) f) = f
opaqueFunctionName (MapS (SVec k _) f_expr) = opaqueFunctionName f_expr
opaqueFunctionName e = error $ "Can't get opaque function name from expression " ++ show e 


{- So I am assuming that I can plumb groupPEltsCallsInApplyT into this. The easiest way seems to be in the actual generator code:

We go through fsig_names_tups and check if the f_expr is in the namesToUniqueNames map. If it is, then it can in principle be merged.
To merge the output arguments, we simply append them in order
What we need to do is change the signature of the function with the "unique name"; and finally we need to make sure that the  generateSubDef for this function is called with the updated function signature. That is a problem because so far I have assume this to be static.

A possible way to do this is to generate only ApplyT in a first pass, and return the updated `functionSignatures` table. Then in a second pass generate all the rest.

            (map (\(f_expr,nms,ms,os) -> case f_expr of
                Function fname _ -> "    call "++fname++"(" ++mkArgList [nms,ms,os] ++")"
                Id fname dt -> unlines $ zipWith (curry (\(o,m) -> "    "++o++" = "++m)) os ms
                ) fsig_names_tups)
            
-}

generateSubDefApplyT :: [Expr]  -> Name -> Map.Map Name FSig -> TyTraCLAST -> (String,[String],Map.Map Name FSig)
generateSubDefApplyT f_exps applyt_fname functionSignatures ast =
    let
        applyt_fsig = functionSignatures ! applyt_fname
        [Tuple nms,Tuple in_args,Tuple out_args] = applyt_fsig
        (_,arg_decls,arg_names) = createArgDeclsAndNames applyt_fsig
        [non_map_arg_decls,in_arg_decls,out_arg_decls] = arg_decls
        [non_map_args'',in_args'',out_args''] = arg_names

        calls_nmsfn = map mkFinalArgSigList nms
        calls_msfn = map mkFinalArgSigList in_args
        calls_osfn = map mkFinalArgSigList out_args

        calls_non_map_args =  map getVarNames calls_nmsfn
        calls_in_args =  map getVarNames calls_msfn
        calls_out_args =  map getVarNames calls_osfn

        fsig_names_tups = zip4 f_exps calls_non_map_args calls_in_args calls_out_args
-- For Id we must rename the args so that they are different. Wonder if I could already do that in the Transform?
    in
        (buildSubDef ""
            applyt_fname
            [non_map_args'',in_args'',out_args'']
            [non_map_arg_decls,in_arg_decls,out_arg_decls]
            (map (\(f_expr,nms,ms,os) -> case f_expr of
                Function fname _ -> "    call "++fname++"(" ++mkArgList [nms,ms,os] ++")"
                Id fname dt -> unlines $ zipWith (curry (\(o,m) -> "    "++o++" = "++m)) os ms
                ) fsig_names_tups)
            False
        ,[],functionSignatures)

-- Comp (Function "f4" []) (Function "f_maps_v_3_0" []))
-- nms are joint
-- ms is for f2
-- os is for f1
generateSubDefComp :: Expr -> Expr -> Name -> Map.Map Name FSig -> TyTraCLAST -> String
generateSubDefComp f1_exp f2_exp comp_fname functionSignatures ast =
    let
        Function fname1 _ = f1_exp
        Function fname2 _ = f2_exp
        fsig1 = functionSignatures ! fname1
        comp_fsig = functionSignatures ! comp_fname
        [Tuple nms,_,_] = comp_fsig
        (_,arg_decls,arg_names) = createArgDeclsAndNames comp_fsig
        [non_map_arg_decls,in_arg_decls,out_arg_decls] = arg_decls
        [non_map_args'',in_args'',out_args''] = arg_names

        calls_nmsfn = map mkFinalArgSigList nms
        [non_map_args1,non_map_args2] =  map getVarNames calls_nmsfn
        [_,ms1',_] = fsig1
        ms1 = mkFinalArgSigList ms1'
        local_var_decls = createDecls ms1
        tmp_args = getVarNames ms1

    in
        buildSubDef ""
            comp_fname
            [non_map_args'',in_args'',out_args'']
            [non_map_arg_decls,in_arg_decls,out_arg_decls,local_var_decls]
            [
                "    call "++fname2++"(" ++mkArgList [non_map_args2,in_args'',tmp_args] ++")"
              , "    call "++fname1++"(" ++mkArgList [non_map_args1,tmp_args,out_args''] ++")"
            ]
            False
        -- unlines [
        --     "subroutine "++comp_fname++"("  ++mkArgList [non_map_args'',in_args'',out_args'']++")"
        --     , mkDeclLines [non_map_arg_decls,in_arg_decls,out_arg_decls,local_var_decls]
        --     , "    call "++fname2++"(" ++mkArgList [non_map_args2,in_args'',tmp_args] ++")"
        --     , "    call "++fname1++"(" ++mkArgList [non_map_args1,tmp_args,out_args''] ++")"
        --     ,"end subroutine "++comp_fname
        -- ]

-- (Function "f_fcomp_acc3_1_2" [],FComp (Function "f2" []) (Function "f_comp_acc3_1_1" []))
-- (b -> a -> b) -> (c->a) -> (b -> c -> b)

-- nms are joint
-- ms is for f2
-- os is for f1
-- acc is retained from f1; there is no os
generateSubDefFComp :: Expr -> Expr -> Name -> Map.Map Name FSig -> String
generateSubDefFComp f1_exp f2_exp fcomp_fname functionSignatures =
    let
        Function fname1 _ = f1_exp
        Function fname2 _ = f2_exp
        fsig1 = functionSignatures ! fname1
        fcomp_fsig = functionSignatures ! fcomp_fname
        [Tuple nms,_,_,_] = fcomp_fsig
        (_,arg_decls,arg_names) = createArgDeclsAndNames fcomp_fsig
        [non_map_arg_decls,acc_arg_decls,in_arg_decls,out_arg_decls] = arg_decls
        [non_map_args'',acc_args'',in_args'',out_args''] = arg_names

        calls_nmsfn = map mkFinalArgSigList nms
        [non_map_args1,non_map_args2] =  map getVarNames calls_nmsfn
        [_,_,ms1',_] = fsig1
        ms1 = mkFinalArgSigList ms1'
        local_var_decls = createDecls ms1
        tmp_args = getVarNames ms1

    in
        buildSubDef "! TO BE CHECKED!"
            fcomp_fname
            [non_map_args'',acc_args'',in_args'',out_args'']
            [non_map_arg_decls,acc_arg_decls,in_arg_decls,out_arg_decls,local_var_decls]
            [
                "    call "++fname2++"(" ++mkArgList [non_map_args2,in_args'',tmp_args] ++")"
              , "    call "++fname1++"(" ++mkArgList [non_map_args1,acc_args'',tmp_args,out_args''] ++")"
            ]
            False
    -- unlines [
    --         "! TO BE CHECKED!",
    --         "subroutine "++fcomp_fname++"("  ++mkArgList [non_map_args'',acc_args'',in_args'',out_args'']++")"
    --         , mkDeclLines [non_map_arg_decls,acc_arg_decls,in_arg_decls,out_arg_decls,local_var_decls]
    --         , "    call "++fname2++"(" ++mkArgList [non_map_args2,in_args'',tmp_args] ++")"
    --         , "    call "++fname1++"(" ++mkArgList [non_map_args1,acc_args'',tmp_args,out_args''] ++")"
    --         ,"end subroutine "++fcomp_fname
    --     ]

-- essentially, select the idx of the tuple as the output of this sub
-- but this seems a bit silly as it means I have the same function n times
generateSubDefElt idx f_exp felt_name functionSignatures =
    let
        Function fname _ = f_exp
        fsig = functionSignatures ! fname
        (_,arg_decls,arg_names) = createArgDeclsAndNames fsig
        [non_map_arg_decls,in_args_decl,out_args_decl] = arg_decls
        [non_map_args,in_args,out_args] = arg_names

        sel_out_arg = out_args !! idx
    in
        buildSubDef ""
            felt_name
            [non_map_args,in_args,[sel_out_arg]]
            [non_map_arg_decls,in_args_decl,out_args_decl]
            [
                "    call "++fname++"(" ++mkArgList [non_map_args,in_args,out_args] ++")"
            ]
            False
        -- unlines [
        --     -- ("! ELT: FLATTENED, NUBBED: \n! " ++(show nms)++"\n! "++(show in_arg)++"\n! "++(show out_arg)) ,
        --     "subroutine "++felt_name++"("  ++mkArgList [non_map_args,in_args,[sel_out_arg]]++")"
        --     , mkDeclLines [non_map_arg_decls,in_args_decl,out_args_decl]
        --     , "    call "++fname++"(" ++mkArgList [non_map_args,in_args,out_args] ++")"
        --     ,"end subroutine "++felt_name
        -- ]

generateSubDefElts :: [Int] -> Expr -> String -> Map.Map Name [Expr] -> TyTraCLAST -> String
generateSubDefElts idxs f_exp felts_name functionSignatures ast =
    let
        Function fname _ = f_exp
        fsig = functionSignatures ! fname
        (_,arg_decls,arg_names) = createArgDeclsAndNames fsig
        [non_map_arg_decls,in_args_decl,out_args_decl] = arg_decls
        [non_map_args,in_args,out_args] = arg_names

        sel_out_args = map (\idx -> out_args !! idx) idxs
    in
        buildSubDef ""
            felts_name
            [non_map_args,in_args,sel_out_args]
            [non_map_arg_decls,in_args_decl,out_args_decl]
            [
                "    call "++fname++"(" ++mkArgList [non_map_args,in_args,out_args] ++")"
            ]
            False

createArgDeclsAndNames argts = let
        argts_fn = map mkFinalArgSigList argts
        arg_names = map getVarNames argts_fn
        arg_decls =  map createDecls argts_fn
    in
        (argts_fn,arg_decls,arg_names)
-- Because we have simply tupled the args for all elts in the apply,
-- we can simply untuple them. So from applyt_fsig, we unpack the tuples \(Tuple es) -> es
mkFinalArgSigList :: Expr -> Expr
mkFinalArgSigList nmst = Tuple $ nub $ (\arg -> case arg of
        Tuple es -> es
        e -> [e]
        ) (flattenSigExpr nmst)

mkFinalVecs :: Expr -> Expr
mkFinalVecs = flattenSigExpr

-- This function rewrites an expressions so that it becomes a single tuple of Scalar or nested SVec
flattenSigExpr :: Expr -> Expr
flattenSigExpr dt = rewriteDTRec dt (Tuple [])
-- We need to call rewriteDT' repeatedly untill all occurences of Tuple [Tuple ] have gone
rewriteDTRec dt dt'
    | dt == dt' = dt
    | otherwise = rewriteDTRec  (rewriteDT' dt) dt

-- The result is that Tuple is always on the outside and SVec is nested 
rewriteDT' :: Expr -> Expr
rewriteDT' dt = case dt of
    SVec sz (Tuple dts) ->  Tuple (map (SVec sz . rewriteDT') dts)
    SVec sz (SVec sz2 dt2) ->  SVec sz (rewriteDT' (SVec sz2 dt2))
    SVec sz dt2 ->  dt
    Tuple dts -> Tuple $ concatMap (\dt -> case dt of
                        Tuple dts -> map rewriteDT' dts
                        SVec sz2 dt2 -> [ rewriteDT' (SVec sz2 dt2)]
                        Vec sz2 dt2 -> [ rewriteDT' (Vec sz2 dt2)]
                        dt' -> [ dt']
                        ) dts
    Vec sz (Tuple dts)  -> Tuple (map (Vec sz . rewriteDT') dts)
    ZipT dts -> ZipT $ concatMap (\dt -> case dt of
        Tuple dts -> map rewriteDT' dts
        SVec sz2 dt2 -> [ rewriteDT' (SVec sz2 dt2)]
        Vec sz2 dt2 -> [ rewriteDT' (Vec sz2 dt2)]
        dt' -> [ dt']
        ) dts
    _ -> dt

createIter :: Expr -> [String]
createIter (SVec sz dt) = let
        vn = getName dt
        --now vn could be Single or Composite
    in
        case dt of
            -- we know this can only be either nested DSVec or terminal
            SVec _ _  ->  let
                    (szs,_) = getSzFromSVec dt []
                    colons = map (const ":") szs
                in
                    ["("++commaSepList ("i":colons) ++")"]
            -- we know this has no tuples inside it  
            -- It means that if vn is Composite (and it should be!), we can zip the names with dts
            Tuple dts -> let
                        Composite vns = vn
                    in createIter (
                            Tuple (
                                zipWith (curry (\(vn',dt) -> SVec sz (setName vn' dt))) vns dts
                                )
                            )
            dt -> ["(i)"]
createIter (Tuple es) = concatMap createIter es
createIter other =  error $ show other

createIODecls :: Maybe FIntent -> Expr -> [FDecl]
createIODecls intent (SVec sz dt)  = let
        vn = getName dt
    in
        case dt of
            -- we know this can only be either nested DSVec or terminal
            SVec _ _  ->  let
                    (szs,dt') = getSzFromSVec dt []
                    Single vn' = vn
                in
                    [ MkFDecl (fortranType dt') (Just (sz:szs)) intent [ vn']  ]
            -- we know this has no tuples inside it                
            Tuple dts -> let
                     Composite vns = vn
                in
                    createIODecls intent (
                        Tuple (
                            zipWith (curry (\(vn',dt) -> SVec sz (setName vn' dt))) vns dts
                            )
                    )
            dt -> let
                        Single vn' = vn
                in
                    [MkFDecl (fortranType dt) (Just [sz]) intent [vn'] ]

createIODecls intent (Scalar _ DDC vn) =  error "DDC!"
createIODecls intent sdt@(Scalar _ dt vn) = [MkFDecl (fortranType sdt) Nothing intent [vn]]
createIODecls intent (Tuple es) = concatMap (createIODecls intent)  es
createIODecls intent other = error $ show other

createDecls :: Expr -> [String]
createDecls (SVec sz dt) = let
        vn = getName dt
    in
        case dt of
            -- we know this can only be either nested DSVec or terminal
            SVec _ _  ->  let
                    (szs,dt') = getSzFromSVec dt []
                    Single vn' = vn
                in
                    [fortranType dt'++", dimension("++commaSepList (map show (sz:szs))++") :: "++ vn']
            -- we know this has no tuples inside it                
            Tuple dts -> let
                     Composite vns = vn
                in
                    createDecls (
                        Tuple (
                            zipWith (curry (\(vn',dt) -> SVec sz (setName vn' dt))) vns dts
                            )
                    )
            dt -> let
                        Single vn' = vn
                in
                    [fortranType dt++", dimension("++show sz++") :: "++ vn']

createDecls (Scalar _ DDC vn) =  error "DDC!"
createDecls sdt@(Scalar _ dt vn) = [fortranType sdt++" :: "++vn]
createDecls (Tuple es) = concatMap createDecls es

getVarNames :: Expr -> [String]
getVarNames (SVec sz dt) = getVarNames dt
getVarNames (Scalar _ _ vn) = [vn]
getVarNames (Tuple es) = concatMap getVarNames es
getVarNames (ZipT es) = concatMap getVarNames es
getVarNames (Vec _ dt) = getVarNames dt

getSzFromSVec :: Expr -> [Int] -> ([Int],Expr)
getSzFromSVec (SVec sz dt) szs = getSzFromSVec dt (szs++[sz])
getSzFromSVec dt szs = (szs,dt)

mkArgList :: [[String]] -> String
mkArgList  = commaSepList . nub . concat

commaSepList :: [String] -> String
commaSepList = intercalate ", "

mkDeclLines :: [[String]] -> String
mkDeclLines  = unlines . map ("    "++) . concat

generateStencilAppl :: Expr -> Expr -> FName -> Map.Map Name [Integer]  -> (String,[String],[FDecl],(Integer,Integer))
generateStencilAppl s_exp v_exp@(Vec _ dt) sv_name stencilDefinitions =
    let
        Single v_name = getName dt
        v_decl = mainArgDecls ! v_name
        --  MkFDecl "integer"  (Just [252004]) (Just In) ["wet_0"] )
        v_upper_bound = case dim v_decl of
            Just vub -> head vub
            _ -> error $ v_name++" is not a Vector"
        Single lhs_v_name = sv_name
        sv_type = fortranType dt
        extra_in_var_decls
            | noStencilRewrites = [exprToFDecl v_exp]
            | otherwise = []
        (s_names,s_defs,sv_szs) = generateStencilDef' s_exp stencilDefinitions
        -- instead of generating new stencils we can also recompute, simply
        stencil_accesses = intercalate "+" (zipWith (curry (\(s_name,ct)-> s_name++"(s_idx_"++(show ct)++")")) s_names [1..])
        lhs_idx_str =  commaSepList  $ map (\ct -> "s_idx_"++show ct) [1 .. length sv_szs]
        decls = concat [
                map (\(s_name, s_def, sv_sz) -> MkFParamDecl "integer" (Just [sv_sz]) s_name (show s_def)) (zip3 s_names s_defs sv_szs),
                [
                    case sv_name of
                        Single sv_name' -> MkFDecl sv_type (Just sv_szs) Nothing [sv_name']
                        Composite sv_names -> error $ show $ MkFDecl sv_type (Just sv_szs) Nothing (map show sv_names)
                ],
                map (\ct -> MkFDecl "integer" Nothing Nothing ["s_idx_"++show ct] ) [1 .. length sv_szs]
            ]
        decl_lines =
            map (\(s_name, s_def, sv_sz) -> ("integer, parameter, dimension("++(show sv_sz)++") :: "++s_name++" = "++(show s_def))) (zip3 s_names s_defs sv_szs)++
            [
            -- if the $sv_type is DDC, it means we need to lookup the type from the definition, which will likely be a zip            
                case sv_name of
                    Single sv_name' -> sv_type++", dimension("++commaSepList (map show sv_szs)++") :: "++sv_name'
                    Composite sv_names -> error $ sv_type++", dimension("++commaSepList (map show sv_szs)++") :: "++show sv_names
            ]++map (\ct -> "integer :: s_idx_"++(show ct) ) [1 .. length sv_szs]
        lb :: Integer
        lb = minimum $ nub $ concat s_defs
        ub :: Integer
        ub = maximum $ nub $ concat s_defs
    in
        -- FIXME
        -- WV 2021-06-02 This is a hack really: I don't quite know how to handle the combined stencil accesses
        -- So when they exceed the array bounds, I replace them by the value at idx instead.
        (unlines $ concat [
            ["! Stencil "++ show (getName s_exp)],
            zipWith (curry (\(sv_sz,ct) -> "    do s_idx_"++(show ct)++" = 1,"++(show sv_sz))) sv_szs [1..],
            [
                "        if (idx+"++stencil_accesses++">=1 .and. idx+"++stencil_accesses++"<="++(show v_upper_bound)++") then",
             "            "++lhs_v_name++"("++lhs_idx_str++") = "++v_name++"(idx+"++stencil_accesses++")",
             "        else",
             "            "++lhs_v_name++"("++lhs_idx_str++") = "++v_name++"(idx)",
             "        end if"
             ],
            replicate (length sv_szs) "    end do"
          ]
        ,decl_lines,decls++extra_in_var_decls
        ,(lb,ub))

generateStencilAppl s_exp v_exp@(ZipT vs_exps') sv_name stencilDefinitions = let
        ZipT vs_exps = mkFinalVecs v_exp
        gen_stencils :: [String]
        -- [(String,[String])] -> ([String], [[String]])
        (gen_stencils,decl_lines,decls,bs) = case sv_name of
            Composite sv_names -> unzip4 $ zipWith (curry (\(v_exp,sv_name') -> generateStencilAppl s_exp v_exp sv_name' stencilDefinitions)) vs_exps sv_names
            Single sv_name' -> unzip4 $ zipWith (curry (\(v_exp,ct) -> generateStencilAppl s_exp v_exp (Single (sv_name'++"_"++(show ct))) stencilDefinitions)) vs_exps [0..] -- SHOULD NOT OCCUR!            
        -- I want to "zip" them but it's a list of lists, so I need to round-robin over it
        gen_stencils_lines :: [[String]]
        gen_stencils_lines = map lines gen_stencils
        grouped_lines :: [[String]]
        grouped_lines = pairUpZipCode gen_stencils_lines []
        -- grouped_lines = gen_stencils_lines
        unique_grouped_lines :: [[String]]
        unique_grouped_lines = map nub grouped_lines
        all_lines :: [String]
        all_lines = concat unique_grouped_lines
    in
        (unlines all_lines, concat decl_lines, concat decls,merge_bounds bs)

merge_bounds :: [(Integer,Integer)] -> (Integer, Integer)
merge_bounds bs = let
        (ls,us) = unzip bs
    in
        (minimum ls, maximum us)

-- some kind of a fold where the result is, if I start from n lists, with each list k lines, then I will have k lists of n lines
-- so for each of these n lists I take the head , that gets me n lines
pairUpZipCode :: [[a]] -> [[a]] -> [[a]]
pairUpZipCode lsts acc
            | null (head lsts) = acc
            | otherwise =
                let
                    (l1,rest) = unzip  $ map (\(x:xs) -> (x,xs)) lsts -- which is a list of tuples                    
                in
                    pairUpZipCode rest (acc++[l1])

generateStencilDef' :: Expr -> Map.Map Name [Integer] -> ([String],[[Integer]],[Int])
generateStencilDef' s_exp stencilDefinitions =
     case s_exp of
        SVec sv_sz sv_exp -> let
                    Single s_name = getName sv_exp
                in
                    case Map.lookup s_name  stencilDefinitions of
                        Just s_def -> ([s_name],[s_def], [length s_def])
        SComb s1 s2 -> let
                (s1_name,s1_def, len_s1) = generateStencilDef' s1 stencilDefinitions
                (s2_name,s2_def, len_s2) = generateStencilDef' s2 stencilDefinitions
                scomb_name = s1_name++s2_name
                -- scomb_def = [ x+y | x <- s1_def, y <- s2_def]
            in
                (scomb_name, s1_def++s2_def,len_s1++len_s2) -- [length s1_def, length s2_def])                


generateVecAssign lhs rhs = let
        Single rhs_vec_name = getName rhs
        Single lhs_vec_name = getName lhs
        -- WV 2021-05-14 added (idx) as all our functions should be on scalars (?)
        -- This is wrong because what we need is stageArgDecls, not mainArgDecls!
        -- We need to determine these from the stage AST!
        assign_str = "    "
            ++lhs_vec_name++( if isLocalScalar then "" else "(idx)")
            ++" = "
            ++rhs_vec_name++( if isLocalScalar' then "" else "(idx)")
        -- WV 2021-05-14 if the LHS is not an arg, both LHS and RHS should be scalars I think
        (rhs_vec_decl,isLocalScalar')
            | rhs_vec_name `Map.member` mainArgDecls = (mainArgDecls ! rhs_vec_name , False) -- risky, might be indirect! FIXME
            | otherwise = (exprToFDecl $ (\(Vec _ s) -> s) rhs, True) -- A brave attempt
        (lhs_vec_decl,isLocalScalar)
            | lhs_vec_name `Map.member` mainArgDecls = (mainArgDecls ! lhs_vec_name , False) -- risky, might be indirect! FIXME
            | otherwise = (exprToFDecl $ (\(Vec _ s) -> s) lhs, True) -- A brave attempt
            -- Vec VT (Scalar VT DFloat "vec_u_0_1")
        -- rhs_vec_decl = lhs_vec_decl{intent=Nothing,names=[rhs_vec_name]}
        rhs_vec_decl' = rhs_vec_decl{intent=Nothing}
        rhs_vec_decl_str =  show rhs_vec_decl
            -- (take (length lhs_vec_decl - length ", intent(out) :: " - length lhs_vec_name) lhs_vec_decl) ++ " :: "++rhs_vec_name
    in
        (assign_str,[rhs_vec_decl_str],[rhs_vec_decl'])

generateMap functionSignatures f_exp v_exp t = -- (Single ov_name)
    let
        Function fname nms_exps = f_exp
        (lhs,rhs) = t
        out_vars_lst = getName lhs
        -- Map _ rhs_v_exp = rhs -- ZipT [Vec VI (Scalar VDC DFloat "va_0"),Vec VI (Scalar VDC DFloat "vc_0")]
        rhs_v_exp = getRhsExpr rhs
        -- rhs_v_exp = case rhs_v_exp' of
        --     ZipT _ -> error $ show rhs_v_exp' -- 
        --     _ -> rhs_v_exp'
        -- I reason that output variables *must* be unique
        (out_vars_name_lst,extra_out_var_decls) = case out_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls
                                    then ([ov_name''++"(idx)"],[] )
                                    else
                                        if noStencilRewrites
                                            then
                                                -- ([ov_name''++"(idx)"],[getDeclFromExprByName ov_name'' lhs])
                                                case lhs of
                                                    Vec VT _ ->  ([ov_name''],  [exprToFDecl lhs])
                                                    _ -> ([ov_name''],[])
                                            else
                                                 ([ov_name''],[])
            Composite ov_names -> let
                    Composite fl_ov_names = flattenNames (Composite ov_names)
                in
                    -- [([a],[b]] -> ([[a]],[[b]]) 
                    bimap concat concat $
                        unzip $ map (\(Single ov_name'') ->
                            if Map.member ov_name'' mainArgDecls
                                then  ([ov_name''++"(idx)"],[])
                                else
                                    if noStencilRewrites
                                                then
                                                    -- ([ov_name''++"(idx)"],[getDeclFromExprByName ov_name'' lhs])
                                                    case lhs of
                                                        Vec VT _ ->  ([ov_name''],  [exprToFDecl lhs])
                                                        _ -> ([ov_name''],[])
                                                else
                                                    ([ov_name''],[])
                                -- ov_name'') fl_ov_names,exprToFDecls lhs) -- map (\(Single ov_name'') -> 
                                    ) fl_ov_names

        nms_vars_lst = nub $ map (show . getName) nms_exps
        nms_decls = concatMap exprToFDecls nms_exps
        -- WV 2021-05-13
        -- The code below is a bit sloppy. 
        -- I think the TyTraCL we provide can be assumed to have been decomposed so that there are no nested maps etc
        -- But I am not sure, and I feel I should handle this with recursion
        in_vars_lst =  getName rhs_v_exp
        (in_vars_name_lst, extra_in_var_decls) = case in_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls
                                    then ([ov_name''++"(idx)"] ,[])
                                    else
                                        if noStencilRewrites -- means we need the temp arg decls too
                                            then
                                                -- ([ov_name''++"(idx)"],[getDeclFromExprByName ov_name'' rhs_v_exp])
                                                case rhs_v_exp of
                                                    Vec VT _ ->  ([ov_name''++"(idx)"] , exprToFDecls rhs_v_exp)
                                                    _ -> ([ov_name''],[]) -- Stencil vecs come here
                                            else
                                                ([ov_name''],[]) -- temp vars will be removed
            Composite ov_names -> let
                    Composite fl_ov_names = flattenNames (Composite ov_names)
                in bimap concat concat $ -- [([],[])] -> ([[]],[[]])
                    unzip $ map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls
                        then  ([ov_name''++"(idx)"], [getDeclFromExprByName ov_name'' rhs_v_exp])
                        else
                            if noStencilRewrites
                                then
                                    -- ([ov_name''++"(idx)"],[getDeclFromExprByName ov_name'' rhs_v_exp])
                                    case rhs_v_exp of
                                        ZipT _ -> ([ov_name''++"(idx)"],[getDeclFromExprByName ov_name'' rhs_v_exp])
                                        _ -> error $ show ov_name'' -- ([ov_name''],[]) -- probably WRONG!
                                else
                                    ([ov_name''],[])
                        ) fl_ov_names
        in_vars_name_lst_str' =  map snd (nubTup $ zip (unwrapName sig_in_args_lst) in_vars_name_lst)

        fsig = functionSignatures ! fname
        [_,v_exp',_] = fsig
        sig_in_args_lst = getName $ flattenSigExpr v_exp'
    in
        (
            unlines [
            "! Map",
            "    call "++fname++"("++
                mkArgList [nms_vars_lst, in_vars_name_lst_str',out_vars_name_lst]
                 ++ ")",
            "" ]
        ,[],nms_decls++extra_in_var_decls++extra_out_var_decls)

-- getDeclFromZipByName :: String -> Expr -> FDecl
-- getDeclFromZipByName name (ZipT exprs) = let
--     -- ZipT [Vec VT (Scalar VDC DFloat "va_1"),Vec VT (Scalar VDC DFloat "vb_1")]
--         decls = map exprToFDecl exprs
--     in
--         head $ filter (\decl -> name == getNameFromDecl decl) decls
-- getDeclFromZipByName name expr = exprToFDecl expr

getDeclFromExprByName :: String -> Expr -> FDecl
getDeclFromExprByName name expr = let
        decls = exprToFDecls expr
        maybe_decl = filter (\decl -> name == getNameFromDecl decl) decls
    in
        -- maybe_decl
        if null maybe_decl then errorDecl else head maybe_decl
        -- if null maybe_decl then Nothing else Just $ head maybe_decl

exprToFDecls :: Expr -> [FDecl]
exprToFDecls s_expr@(Scalar _ _ vname)  = [MkFDecl (fortranType s_expr) Nothing (Just In) [vname]]
exprToFDecls sv_expr@(SVec sz (Scalar _ _ vname) ) = [MkFDecl (fortranType sv_expr) (Just [sz]) (Just In) [vname]]
exprToFDecls (Vec _ s_expr@(Scalar _ _ vname))  = [MkFDecl (fortranType s_expr) (Just [vSz]) Nothing [vname]]
exprToFDecls (Vec _ (SVec sz s_expr@(Scalar _ _ vname) ))  = [MkFDecl (fortranType s_expr) (Just [vSz]) Nothing [vname]]
exprToFDecls (ZipT exprs) = concatMap exprToFDecls exprs
-- Tuple [Vec VO (Scalar VDC DFloat "h_0"),Vec VO (Scalar VDC DFloat "u_0"),Vec VO (Scalar VDC DInt "wet_1")]
exprToFDecls (Tuple exprs) = concatMap exprToFDecls exprs
exprToFDecls expr = error $ show expr


exprToFDecl :: Expr -> FDecl
exprToFDecl s_expr@(Scalar _ _ vname)  = MkFDecl (fortranType s_expr) Nothing (Just In) [vname]
exprToFDecl sv_expr@(SVec sz (Scalar _ _ vname) ) = MkFDecl (fortranType sv_expr) (Just [sz]) (Just In) [vname]
exprToFDecl (Vec _ s_expr@(Scalar _ _ vname))  = MkFDecl (fortranType s_expr) (Just [vSz]) Nothing [vname]
exprToFDecl (Vec _ (SVec sz s_expr@(Scalar _ _ vname) ))  = MkFDecl (fortranType s_expr) (Just [vSz]) Nothing [vname]

exprToFDecl expr = error $ show expr


-- I think the difference between fold and map is the acc and the output type
-- In principle the accumulator could be a tuple, so the code as is is not generic!
generateFold functionSignatures f_exp acc_exp v_exp t =
    let
        Function fname nms_exps = f_exp
        fsig = functionSignatures ! fname
        [_,_,v_exp',_] = fsig
        sig_in_args_lst = getName $ flattenSigExpr v_exp'
        -- sig_acc_args_lst = getName $ flattenSigExpr acc_exp'

        (lhs,rhs) = t
        out_vars_lst = getName lhs
        Fold _ _ rhs_v_exp = rhs -- fold f acc v
        (out_var_name, extra_out_var_decls) = case out_vars_lst of
            Single ov_name'' -> (ov_name'',[])
        -- WV 2021-05-20 this is WRONG: we *never* need to index the accumulator, even if it was a vector
            -- if Map.member ov_name'' mainArgDecls
            --                         then (ov_name''++"(___idx)" ,[])
            --                         else (ov_name'',[])
            Composite ov_names -> error $ show $ map (\(Single ov_name'') ->  ov_name'') ov_names -- TODO
        -- WV 2021-05-20 this is WRONG: we *never* need to index the accumulator, even if it was a vector
            -- if Map.member ov_name'' mainArgDecls then  ov_name''++"(_X_idx)" else  ov_name'') ov_names
        nms_vars_lst =  nub $ map (show . getName) nms_exps
        nms_decls
            | foldl (\acc exp -> acc || isZipT exp) False nms_exps = error $ show nms_exps
            | otherwise = map exprToFDecl nms_exps
        in_vars_lst =  getName rhs_v_exp
        (in_vars_name_lst, extra_in_var_decls) = case in_vars_lst of
            Single ov_name'' -> if Map.member ov_name'' mainArgDecls
                                    then ([ov_name''++"(idx)"],[] )
                                    else
                                        if noStencilRewrites
                                            then
                                                case rhs_v_exp of
                                                    -- Vec VS _ ->  ([ov_name''++"(idx)"], [exprToFDecl rhs_v_exp]) 
                                                    Vec VT _ ->  ([ov_name''++"(idx)"] , [exprToFDecl rhs_v_exp]) -- probably WRONG!
                                                    _ ->  ([ov_name''],[])
                                            else
                                                ([ov_name''],[])
            Composite ov_names -> let
                    Composite fl_ov_names = flattenNames (Composite ov_names)
                in Data.Bifunctor.bimap concat concat $ -- [([],[])] -> ([[]],[[]])
                    unzip $ map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls
                        then  ([ov_name''++"(idx)"], [])
                        else  ([ov_name''],[])
                        ) fl_ov_names
            -- Composite ov_names -> let
            --         Composite fl_ov_names = flattenNames (Composite ov_names)
            --     in
            --         map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls then  ov_name''++"(idx)" else  ov_name'') fl_ov_names
        in_vars_name_lst' =  map snd (nubTup $ zip (unwrapName sig_in_args_lst) in_vars_name_lst)


        -- acc_vars_lst =  getName rhs_acc_exp
        -- acc_vars_name_lst = case acc_vars_lst of
        --     Single ov_name'' -> if Map.member ov_name'' mainArgDecls then [ov_name''++"(idx)"] else [ov_name'']
        --     Composite ov_names -> let
        --             Composite fl_ov_names = flattenNames (Composite ov_names)
        --         in
        --             map (\(Single ov_name'') -> if Map.member ov_name'' mainArgDecls then  ov_name''++"(idx)" else  ov_name'') fl_ov_names
        -- acc_vars_name_lst' =  map snd (nubTup $ zip (unwrapName sig_acc_args_lst) acc_vars_name_lst)            

        -- nms = getVarNames (Tuple nms_exps)
        -- vs_in = getVarNames v_exp
        Scalar _ _ acc_name = acc_exp
        ftype = fortranType acc_exp
    in
        (
            unlines [
        --  show acc_vars_name_lst',
         "! Fold",
        "    call "++fname++"("
        ++ mkArgList [nms_vars_lst,[acc_name] ,in_vars_name_lst',[out_var_name]]
        ++")",
        "    "++acc_name++" = "++out_var_name
            ]
        ,[ftype++", intent(InOut) :: "++acc_name]
        ,[ MkFDecl ftype Nothing (Just InOut) [acc_name] ,
        MkFDecl ftype Nothing (Just Out) [out_var_name]
        ] ++ nms_decls ++extra_in_var_decls++extra_out_var_decls
        )

getInputArgs = everything (++) (mkQ [] getInputArgs')

-- WV this is not quite correct because VT can be an input but it depends on the enture AST
-- So I must do a rewrite of the AST before I call getInputArgs
getInputArgs' :: Expr -> [Name]
getInputArgs' node = case node of
                            Vec VI dt -> [(\(Single vn) -> vn) $ getName dt]
                            -- Vec VT (Scalar VT _ sn) -> []
                            Vec VT dt -> [(\(Single vn) -> vn) $ getName dt | noStencilRewrites]
                            Scalar VI _ sn -> [sn]
                            -- The problem here is that (Vec VT (Scalar VT)) leads to VT being picked
                            Scalar VT _ sn -> [sn] -- WV 2021-06-02 This is a "quick fix" rather than the correct solution which is to rewrite the AST
                            _ -> []

getOutputArgs = everything (++) (mkQ [] getOutputArgs')

getOutputArgs' :: Expr -> [Name]
getOutputArgs' node = case node of
                            Vec VO dt -> [(\(Single vn) -> vn) $ getName dt]
                            Scalar VO _ sn -> [sn]
                            Vec VT dt -> [(\(Single vn) -> vn) $ getName dt | noStencilRewrites]
                            _ -> []

getFSigs :: [Expr] -> Map.Map Name FSig -> [FSig]
getFSigs fs functionSignatures = zipWith (curry (\(f_expr, idx) -> case f_expr of
                   (Function fname _) -> case Map.lookup fname functionSignatures  of
                       Just sig -> sig
                       Nothing -> error $ "getFSigs: no entry for "++fname
                   (Id fname dt) ->  case Map.lookup fname functionSignatures  of
                       Just sig -> sig
                       Nothing -> [Tuple [],Tuple [],Tuple []] -- error $ "getFSigs: no entry for Id "++fname            
            -- [Tuple [], setName ("id_in_"++(show idx)) dt, setName ("id_out_"++(show idx)) dt ]
    )) fs [1..]


-- getFSigs :: [Expr] -> Map.Map Name FSig -> [FSig]
-- getFSigs fs functionSignatures = map (\f_expr -> case f_expr of
--                     (Function fname _) -> case Map.lookup fname functionSignatures  of
--                         Just sig -> sig
--                         Nothing -> error $ "getFSigs: no entry for "++fname
--                     (Id fname dt) ->  case Map.lookup fname functionSignatures  of
--                         Just sig -> sig
--                         Nothing -> [Tuple [],Tuple [],Tuple []] -- error $ "getFSigs: no entry for Id "++fname            
--             -- [Tuple [], setName ("id_in_"++(show idx)) dt, setName ("id_out_"++(show idx)) dt ]
--     ) fs 

{-
For every Map or Fold, a list of the decomposed function definitions and a list of the rest
These are always of the same length
But as we want a single superkernel we will always have all definitions so I can combine them

All ASTs with Map can be combined as the Maps don't depend on one another
This is NOT true for noStencilRewrites, because we still have Stencil calls.
-}
createStages :: [TyTraCLAST] -> (TyTraCLAST,[TyTraCLAST])
createStages asts
    | withStencilRewrites =
        let
            -- For every Map or Fold, a list of the decomposed function defs and a list of the rest
            -- These are always of the same length
            -- But as we want a single superkernel we will always have all defs so I can combine them
            (asts_function_defs, asts_no_function_defs) = unzip $ map (partition isFunctionDef) asts
            -- All ASTs with Map can be combined as the Maps don't depend on one another
            (asts_with_fold,asts_without_fold) = partition hasFold asts_no_function_defs
            ast_without_fold = concat asts_without_fold

        in
            -- error $ show (length asts_function_defs, length asts_no_function_defs, length asts_with_fold, length ast_without_fold)
            (concat asts_function_defs,  asts_with_fold++[ast_without_fold])
    | noStencilRewrites =
        let
            -- For every Map or Fold, a list of the decomposed function defs and a list of the rest
            -- These are always of the same length
            -- But as we want a single superkernel we will always have all defs so I can combine them
            (asts_function_defs, asts_no_function_defs) = unzip $ map (partition isFunctionDef) asts
        in
            (concat asts_function_defs,  asts_no_function_defs)

hasFold ast = let
        fold_exprs = filter (\(lhs, rhs) -> case rhs of
            Fold {} -> True
            _ -> False
            ) ast
    in
        not (null fold_exprs)

isFunctionDef (Function _ _, _) = True
isFunctionDef _ = False

clearIntent ::FDecl -> FDecl
clearIntent decl@MkFDecl {} = decl{intent=Nothing}
clearIntent decl@MkFParamDecl {} = decl

getNameFromDecl :: FDecl -> String
getNameFromDecl decl@MkFDecl {} = head $ names decl
getNameFromDecl decl@MkFParamDecl {} = name decl
-- for every stage:
-- stage_ast is the AST with only non-function-defs


-- I think it might be best to keep a list (or a Set) of the acc variables 
-- That makes it easier to test if a later node needs them
-- Which means the map on line 1075 should become a fold     
generateMainProgramOrSuperkernel :: Bool -> Map.Map Name FSig -> [TyTraCLAST] -> (String,(String,String))
generateMainProgramOrSuperkernel genModule functionSignatures ast_stages  =
    let
        generateStageKernel' :: Map.Map Name FSig -> Integer -> TyTraCLAST -> [String] -> (([String],[FDecl],String),[String], String, (Integer,Integer))
        generateStageKernel' functionSignatures  ct stage_ast  accs = let
                acc_exprs = filter (\(lhs,rhs)-> case rhs of
                                Fold {} -> True
                                _ -> False
                                )  stage_ast
                (maybe_acc_arg, maybe_acc_arg_decl_str,maybe_acc_arg_decl)
                    | null acc_exprs = ([],[],[])
                    | otherwise = let
                            (lhs, _) =  head acc_exprs
                            Scalar _ _ name = lhs
                            decl_str = fortranType lhs ++ ", intent(Out) :: "++name
                            decl = MkFDecl (fortranType lhs) Nothing (Just Out) [name]
                        in
                            ([name],[decl_str], [decl])

                (uniqueGeneratedDecls, uniqueGeneratedDeclLines,generatedStmts,(upperBound,lowerBound)) = generateNonSubDefs functionSignatures stage_ast
                -- uniqueGeneratedDeclLines = generatedDeclLines
                -- now I need to extract all VI and VO from non_func_exprs
                -- best way to do that is with `everything` I think
                -- WV 2021-06-01 VT can be In or Out as well!
                -- So rewrite stage_ast so that VT becomes VI or VO as required
                in_args = nub $ concatMap (\(lhs,rhs) -> getInputArgs rhs) stage_ast
                out_args = nub $ concatMap (\(lhs,rhs) -> getOutputArgs lhs) stage_ast
                -- and I need the declarations for these, so I guess I need to get the Exprs and then the names and decls from there
                -- also I need a mechanism to detect the accs that are passed between the stages
                arg_decl_lines = foldl (\arg_decl_lines arg_name -> case Map.lookup arg_name mainArgDecls of
                                            Just decl -> if show decl{intent=Just InOut} `elem` uniqueGeneratedDeclLines
                                                    then
                                                        arg_decl_lines++[show decl{intent=Just InOut}]
                                                    else
                                                        arg_decl_lines++[show decl]
                                            Nothing -> arg_decl_lines -- error $ "No declaration for "++arg_name++ " in mainArgDecls"
                                    ) [] (in_args++out_args)
                arg_decls = foldl (\arg_decls arg_name -> case Map.lookup arg_name mainArgDecls of
                                            Just decl -> if decl{intent=Just InOut} `elem` uniqueGeneratedDecls
                                                    then
                                                        arg_decls++[ decl{intent=Just InOut}]
                                                    else
                                                        arg_decls++[ decl]
                                            Nothing -> arg_decls -- error $ "No declaration for "++arg_name++ " in mainArgDecls"
                                    ) [] (in_args++out_args)
                -- These are the declarations at top level that are not arguments of the original TyTraCL main as they are temporaries
                -- They are not present in mainArgDecls 
                extra_arg_decls = filter (\decl-> getNameFromDecl decl `elem` in_args++out_args) uniqueGeneratedDecls
                -- It is possible, somehow, that uniqueGeneratedDecls contains the same var as in_args++out_args, but without intent
                -- So I should remove all args that are in arg_decls from uniqueGeneratedDecls
                uniqueGeneratedDecls' =  filter (\decl -> clearIntent decl `notElem` map clearIntent arg_decls ) uniqueGeneratedDecls
                unique_extra_arg_decls = filter (\decl -> clearIntent decl `notElem` map clearIntent arg_decls ) extra_arg_decls
                main_arg_decls = arg_decls ++ unique_extra_arg_decls ++ maybe_acc_arg_decl
                accs' = nub $ accs++maybe_acc_arg
                generatedStageKernelsStr
                    | genStages = unlines $ concat [
                                [
                                    "subroutine stage_kernel_"++show ct++"("++mkArgList [ in_args,out_args]++")"
                                ]
                                -- ,(map ("    "++) $ nub $ (used_acc_decl_lines++arg_decl_lines++maybe_acc_arg_decl_str++uniqueGeneratedDeclLines))
                                ,["! arg_decls"]
                                ,map ( ("    "++) . show ) arg_decls
                                ,["! uniqueGeneratedDecls'"]
                                ,map ( ("    "++) . show )  uniqueGeneratedDecls'
                                ,[""]
                                -- ,map ( ("!    "++) . show ) uniqueGeneratedDecls
                                ,[
                                    "    integer :: idx",
                                    "    call get_global_id(idx,0)",
                                    "!$RF4A Begin Inline"
                                 ]
                                ,generatedStmts
                                ,[
                                    "!$RF4A End Inline",
                                    "end subroutine stage_kernel_"++show ct
                                 ]
                            ]
                    | otherwise = "! Stage kernel code not generated"
            in
                (
                    (arg_decl_lines++maybe_acc_arg_decl_str,
                    main_arg_decls,
                    if genStages
                        then
                            "call stage_kernel_"++show ct++"("++mkArgList [in_args, out_args]++")" -- used_acc_names++, maybe_acc_arg
                        else
                            "! Stage kernel call code not generated"
                    )
                    , accs', generatedStageKernelsStr
                    ,(upperBound,lowerBound)
                )

        (stage_kernel_decls_calls', _, def_lines_strs,boundPairs) =  foldl (\(stage_kernel_decls_calls, accs, def_lines_strs,bps) (ast,ct) ->
            let
                (stage_kernel_decls_calls', accs', def_lines_str,bp) = generateStageKernel' functionSignatures ct ast accs
            in
                (stage_kernel_decls_calls++[stage_kernel_decls_calls'], accs', def_lines_strs++[def_lines_str],bps++[bp])
            ) ([],[],[],[]) (zip ast_stages [1..])

        (_, stage_kernel_decls, stage_kernel_calls) = unzip3 stage_kernel_decls_calls'
        unique_stage_kernel_decls = nubDeclList $ concat stage_kernel_decls
        main_program_decl_strs' =  map (show . clearIntent) unique_stage_kernel_decls
        loops_over_calls = map (\(call_str,(lb,ub)) -> unlines [
            "\ndo global_id = 1, "++(show vSz),
            "  "++call_str,
            "end do"
            ]
            ) (zip stage_kernel_calls boundPairs)
        -- use_statements_for_opaques = map (\fname -> "use singleton_module_"++fname++", only : "++fname++"_scal") (Map.keys scalarisedArgs)
    in
        if genModule
            then (buildMainProgramForSuperkernelDef unique_stage_kernel_decls stage_kernel_calls,
                buildSuperkernelDef unique_stage_kernel_decls stage_kernel_calls def_lines_strs)
            else (buildMainProgramDef main_program_decl_strs' loops_over_calls def_lines_strs,("",""))
    -- unlines $ [
    --     "program main",
    --     -- unlines use_statements_for_opaques,
    --     "integer :: global_id",
    --     "common /ocl/ global_id",
    --     "! Declarations"
    --     ] ++
    --     main_program_decl_strs' ++
    --     ["! Loops over stage calls"] ++
    --     loops_over_calls ++
    --     [
    --     "end program main  "
    --     ] ++
    --     [
    --     "",
    --     "subroutine get_global_id(idx,dim)",
    --     "    "++"integer, intent(out) :: idx",
    --     "    "++"integer, intent(in) :: dim",
    --     "    "++"integer :: global_id",
    --     "    "++"common /ocl/ global_id",
    --     "    "++"idx = global_id",
    --     "end subroutine get_global_id",
    --     ""
    --     ] ++
    --     def_lines_strs
    --     ++ [
    --         ""
    --     ]

-- A helper which nubs a list of FDecls ignoring the Intent        
nubDeclList :: [FDecl] -> [FDecl]
nubDeclList declList = let
        noIntentDeclList = map clearIntent declList
        uniqueNoIntentDeclList = nub noIntentDeclList
        -- now for each element in this list we look for an element in the original list with an intent
        uniqueDeclList = map (\declNoIntent -> head $ foldl (\acc decl -> if null acc && declNoIntent == clearIntent decl then [decl] else acc) [] declList) uniqueNoIntentDeclList
    in
        uniqueDeclList

-- A helper which nubs a list of tuples based on uniqueness of the first element        
nubTup :: Ord a => [(a,b)]  -> [(a,b)]
nubTup lst = fst $ foldl (\(nubbed_lst,occs) (e1,e2) ->
    if Set.member e1 occs
        then
            (nubbed_lst, occs)
        else
            (nubbed_lst++[(e1,e2)], Set.insert e1 occs)
    ) ([],Set.empty) lst

-- The main loop upper bound is the size of the input vectors    
vSz = getVSz  mainArgDeclsList

getVSz  :: [(String,FDecl)] -> Int
getVSz lst = maximum $ map (\(v,r) -> case dim r of
            Nothing -> 0
            Just [sz] -> sz
            Just sz -> product sz
            ) lst


fortranType :: Expr -> String
fortranType (Scalar _ DInt _) = "integer"
fortranType (Scalar _ DInteger _) = "integer"
fortranType (Scalar _ DReal _) = "real"
fortranType (Scalar _ DFloat _) = "real"
fortranType (SVec sz dt) = fortranType dt -- ++", svecdimension("++show sz++")" -- dimension is added in createDecls 
fortranType dt = "! No equivalent Fortran type for "++show dt++" !!! "

-- getAccExprs :: Name -> Expr -> [Expr]
-- getAccExprs acc_name = everything (++) (mkQ [] (getAccExprs' acc_name)) 

-- getAccExprs' :: Name -> Expr -> [Expr]
-- getAccExprs' acc_name node = case node of
--                             Function fname non_map_args -> if 
--                                     Map.member fname functionSignatures 
--                                     && acc_name `elem` (unwrapName $ flattenNames $ getName $ Tuple non_map_args)
--                                 then
--                                     non_map_args
--                                 else
--                                     []                                    
--                             _ -> []

isZipT (ZipT _) = True
isZipT _ = False

getRhsExpr (Map _ rhs_v_exp) = rhs_v_exp
getRhsExpr (Fold _ _ rhs_v_exp) = rhs_v_exp
getRhsExpr (UnzipT exp) = getRhsExpr exp
getRhsExpr exp = error $ show exp


buildSubDef :: String -> String -> [[String]] -> [[String]] -> [String]-> Bool -> String
buildSubDef comment fname list_of_arg_lsts list_of_arg_decl_lsts body_lines isOpaque =
    let
        maybeUseDecl :: String
        maybeUseDecl
            | isOpaque = "    use singleton_module_"++fname++", only : "++fname++"_scal"
            | otherwise = ""
    in
        unlines $ concat
            [
                [
                    comment,
                    "subroutine "++fname++"("  ++(mkArgList list_of_arg_lsts)++")"
                    , maybeUseDecl
                    , mkDeclLines list_of_arg_decl_lsts
                ],
                body_lines,
                [
                    "end subroutine "++fname
                ]
            ]

buildMainProgramDef main_program_decl_strs loops_over_calls subdef_lines_strs =
    unlines $ [
        "program main",
        -- unlines use_statements_for_opaques,
        "integer :: global_id",
        "common /ocl/ global_id",
        "! Declarations"
        ] ++
        main_program_decl_strs ++
        ["! Loops over stage calls"] ++
        loops_over_calls ++
        [
        "end program main  ",
        ""
        ] ++
        getGlobalIdDefStrs
         ++ [""]++
        subdef_lines_strs

buildMainProgramForSuperkernelDef unique_stage_kernel_decls stage_kernel_calls = let
        main_program_decl_strs = map (\decl -> "    "++((show . clearIntent) decl)) unique_stage_kernel_decls
        superkernel_args_str = intercalate ", " $ concatMap names unique_stage_kernel_decls
        case_param_decl_strs = map (\ct ->
            "    integer, parameter :: ST_STAGE_KERNEL_"++(show ct)++" = "++(show ct)++" ! stage_kernel_"++(show ct)
            )  [1.. length stage_kernel_calls]
        loops_over_calls = map (\ct -> unlines [
            "    state_ptr = ST_STAGE_KERNEL_"++(show ct),
            "    do iter = 1, niters",
            "    print *, iter",
            "    do global_id = 1, "++(show vSz),
            "      call "++superkernelName++"("++superkernel_args_str++",state_ptr)",
            "    end do",
            "    end do"
            ]
            ) [1.. length stage_kernel_calls]
    in
    unlines $ [
        "program main",
        "    use module_"++superkernelName++", only : "++superkernelName,
        "    integer :: global_id",
        "    common /ocl/ global_id",
        "    ! Declarations"
        ] ++
        main_program_decl_strs ++
        case_param_decl_strs ++
        [
            "    integer :: state_ptr",
            "    integer, parameter :: niters = 5",
            "    integer :: iter ",
        "    ! Loops over stage calls"] ++
        loops_over_calls ++
        [
        "end program main  "
        ]

buildSuperkernelDef unique_stage_kernel_decls stage_kernel_calls subdef_lines_strs = let
        superkernel_decl_strs = map (\decl -> "    "++(show decl)) unique_stage_kernel_decls
        -- superkernel_decl_strs = map (show . clearIntent) unique_stage_kernel_decls
        superkernel_args_str = intercalate ", " $ concatMap names unique_stage_kernel_decls

        -- case (ST_SHAPIRO_MAP_24)
        --    call shapiro_map_24(wet,etan,eta)    
        stage_call_strs = map (\(call_str,ct)->
            "      case (ST_STAGE_KERNEL_"++(show ct)++")\n"++
            "      "++call_str
            ) $ zip stage_kernel_calls [1..]

        -- integer, parameter :: ST_SHAPIRO_MAP_24 = 1 !  shapiro_map_24
        case_param_decl_strs = map (\ct ->
            "    integer, parameter :: ST_STAGE_KERNEL_"++(show ct)++" = "++(show ct)++" ! stage_kernel_"++(show ct)
            )  [1.. length stage_kernel_calls]
    in
        ( unlines $ [
            "module module_"++superkernelName,
            "    contains",
            "subroutine "++superkernelName++"("++superkernel_args_str++",state_ptr)"
            ] ++
            superkernel_decl_strs ++
            case_param_decl_strs ++
            [
                "    integer :: state",
                "    integer :: state_ptr",
            "    state = state_ptr ! state",
            "! SUPERKERNEL BODY",
            "    select case(state)"
            ] ++
            stage_call_strs ++
            [
                "    end select",
            "end subroutine "++superkernelName
            ] ++ [""] ++
            subdef_lines_strs
            -- ++ getGlobalIdDefStrs            
            ,
                "end module module_"++superkernelName
            )

getGlobalIdDefStrs =
    [
        "subroutine get_global_id(idx,dim)",
        "    "++"integer, intent(out) :: idx",
        "    "++"integer, intent(in) :: dim",
        "    "++"integer :: global_id",
        "    "++"common /ocl/ global_id",
        "    "++"idx = dim ! dummy",
        "    "++"idx = global_id",
        "end subroutine get_global_id"
        ]
