TODO:

- For array slicing and array indexing by arrays: insert guards if undecidable
- Add the discussion of functions-of-functions, including how we could emulate sum types to fix it

Type Safe Higher-Order Functions Fortran


Fortran 77 has limited support for higher-order functions. The issue with the higher order functions is how they are typed. Essentially, when a function f1(x) with type

f1 : t1 -> t2

is passed as argument to a function f2(f), the type of f2 is:

f2 : t2 -> t3

whereas the complete type would be

f2: (t1 -> t2) -> t3

So in Fortran the type of the argument(s) of f1 is not considered. Which means that we can easily write unsafe code:

t3 function f2(f) 
 t2 :: f,y
 t1 :: x
 t4 :: z
 logical :: c
 ...
 if (c) then
 y = f(x)
 else
 y = f(z,x) 
 end if
end function

The f(z,x) call, while patently wrong, will pass silently. 

That's a bit not good, but fortunately all is not lost. The solution comes from a rather unexpected angle: algebraic data types to the rescue. This is a kind of type used by many functional programming languages, and it allows you to say something like "this type of thingy can either be A or B or C etc". In particular, I am going to use an algebraic data type where every type alternative is a function type, something like

datatype F12 = F1 t1 -> t2 | F2 t4 ->t1 ->t2 

Fortran does not have such a type. But with a little trickery we can achieve the same effect.
 
Fortran requires us to explicitly declare which functions will be used as arguments in code unit. So we can look all functions so declared in a code unit, and make a list of their type signatures:

F12 = [ t1 -> t2 , t4 ->t1 ->t2 ] 

The index in this list is a unique identifier for that type,  F12[1] refers to the first type, F12[2] to the second.

And now we can do this:

t3 function f2(idx,f)
 integer :: idx 
 t2 :: f,y
 t1 :: x
 t4 :: z
 logical :: c
 ...
 if (c) then
if (idx==1) then
 y = f(x)
else
error('Type error!')
end if
 else
if (idx==2) then
 y = f(z,x) 
else
error('Type error!')
end if
 end if
end function

And so our higher-order functions are type safe at run time. In practice, the "we" is a refactoring compiler, so the programmer does not need to do anything.




  
 





Sum types for functions of functions:

There is one corner case which I fear is ultimately undecidable:

say
f12 :: Int -> Int
 f12(x,y) {y=x*x}
 integer, intent(in) :: x
 integer, intent(out) :: y
f21 :: Int -> Int
 f21(x,y) {x=y*y}
 integer, intent(out) :: x
 integer, intent(in) :: y
 
 if we have then:
 
 sf(f)
 external f
 integer :: x
 integer :: y
 call f(x,y)
 
 then the type of the call is Int -> Int and 
 integer, intent(inout) :: x
 integer, intent(inout) :: y
 
 unless we can refine the intent from the context. But that is not always statically decideable.
 
 for example:
 
 x=1
 y=2
 call f(x,y)
 z=x+y ! 1+2*2 or 1*1+2
 
 One can wonder how this is different from having just two different functions, e.g. x+2*y and 2*x+y
It is impossible to tell from the type which one is the correct one. But is this really a type error? 
Well, in a decent language, you know the arguments are in and the return values out, so this is what the difference is. 

But in Fortran, the call syntax makes it impossible to say if

call f(x1:t,x2:t,x3:t) has type
f: (x1,x2) -> x3
or
f: x1 -> (x2,x3)
or
f: x2 -> (x1,x3)

And this is after InOut to In+Out rewrite, otherwise it could even be

f: (x2,x1) -> (x1,x3)

The best thing we can do is distinguish in the type system between

f(x:t:in,y:t:out)
and
f(x:t:out,y:t:in)

Either by including the intent in the type as above, or by adding the position to the type:

f : t:2 -> t:1 

which lets us reconstruct the intent. In the call typecheck rule the intent makes most sense, and it is simply (FortranType,Intent)

https://typing-is-hard.ch/

Completeness

A type checker is complete if it can check every correctly typed program.

Soundness

A type checker is sound if it only accepts correctly typed programs.

Basic Type Safety

An intuitive notion of type safety is pithily summarized by the phrase, “Well typed programs cannot go wrong.” This phrase was coined by Robin Milner in his 1978 paper, A Theory of Type Polymorphism in Programming. Let’s deconstruct this phrase and define its parts, considering the second part first.


In this paper we present the program transformations and type checking algorithms required to convert FORTRAN 77 subroutines and functions into pure, side-effect free subroutines and functions in Fortran 95. The resulting code is type safe and the pure, side-effect free subroutines can readily be offloaded to accelerators.

[[
So we must show that our type checker is sound and complete for the parts that we are interested in. 

ANSI X3.9-1978 Revision of ANSI X3.9-1966
American National Standard Programming Language FORTRAN

2.13 Storage
A storage sequence is a sequence of storage units. A storage unit is either a numeric storage unit or a character storage unit.
An integer, real, or logical datum has one numeric storage unit in a storage sequence. A double precision or complex datum has two numeric storage units in a storage sequence.
A character datum has one character storage unit in a storage sequence for each character in the datum. This standard does not specify a relationship between a numeric storage unit and a character storage unit.
If a datum requires more than one storage unit in a storage sequence, those storage units are consecutive.
The concept of a storage sequence is used to describe relationships that exist among variables, array elements, arrays, substrings, and common blocks. This standard does not specify a relationship between the storage sequence concept and the physical properties or implementation of storage.


The six types of data are:
(1) Integer
(2) Real
(3) Double precision
A double precision datum has two consecutive numeric storage units in a storage sequence
(4) Complex
A complex datum is a processor approximation to the value of a complex number. The representation of a complex datum is in the form of an ordered pair of real data. The first
of the pair represents the real part of the complex datum and the second represents the
imaginary part. Each part has the same degree of approximation as for a real datum. A
complex datum has two consecutive numeric storage units in a storage sequence; the first
storage unit is the real part and the second storage unit is the imaginary part.
(5) Logical
(6) Character




https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Language.html

The standard does not specify the size of a numeric storage unit, nor does it speficy a relationship between a numeric storage unit and a character storage unit. However, the consensus amongst Fortran compilers is as follows:

(1) Integer: 4
(2) Real: 4
(3) Double precision: 8
(4) Complex: 8, 
Double Complex: 16
(5) Logical: 4
(6) Character: 1


Technically, the use of kinds in type declarations is not part of the FORTRAN 77 specification. It is however widely used and supported by all current Fortran compilers, in particular g77. Therefore we treat all types as (typename, kind) tuples. This allows us the simplify the types to integer, real, logical and character, because we write 

Double precision: (real,8)
Comples:  ((real,4),(real,4))
Double Complex ((real,8),(real,8))

Type safety of type coercions: Fortran compilers warn 


]]


In terms of structure of the paper:

* Fortran still matters

Show bibliographic data, Archer load, see other paper

* Acceleration by offloading matters

Hardware accelerators have proven extremely effective in accelerating scientific code. Of the Green Top 10 (https://www.top500.org/lists/green500/2019/11/), 8 systems use accelerators. However, in practice the accelertors have their own memory, and the most common compute model is still to offload part of the calculation to the accelerator and copy the results back to the host memory. Even if the accelerator is cache-coherent with the host memory, having the code to be run on the accelertor in a separate memory space is still advantageous as it results in reduced coherency traffic.

Cite success of heterogeneous supercomputers etc

* Therefore we need self-contained ("pure") functions

- no shared memory space
- no system calls 
- no library calls except intrinsic ones
- no I/O

* Related work: see earlier paper, be nice to CamFort





* Preliminaries

- fully explicit typing

F77 allows types to me infered based on the first character
This is necessary because without it there is no referential transparency 
(and type checking) i.e. make convert IMPLICIT rules into type declarations (algo)

We parse all IMPLICIT statements and turn them into a lookup table Char => (Type,ArrayOrScalar,Attribute)
This lookup table is initially populated with the default rule:

    implicit integer (i-n), real (a-h, o-z)

We analyse all relevant lines for occurnences of undeclared variables and add declarations following the IMPLICIT rules.


- Removal of COMMON blocks

From the spec:


The COMMON statement provides a means of associating entities in different program units. This allows different program units to define and reference the same data without using arguments, and to share storage units.


(From the F95 spec:
"The COMMON statement specifies blocks of physical storage, called common blocks, that may be
accessed by any of the scoping units in a program. Thus, the COMMON statement provides a
global data facility based on storage association.

Storage sequences are used to describe relationships that exist among variables, common blocks,
and result variables. Storage association is the association of two or more data objects that occurs
when two or more storage sequences share or are aligned with one or more storage units.
"
)

Our approach is to convert COMMON block variables into subroutine arguments. The more common approach of conversion into module-scoped variables is not suitable for our purpose because it does not result in pure functions. (Furthermore, because of the difference in semantics of storage association and module scoped variables, this approach only works for COMMON blocks where all variables are aligned, whereas COMMON blocks allow overlapping sequences). One of the main contributions of this paper is in this conversion and the associated type checks.

1. construct the COMMON block chain

In a subroutine call chain, it is not necessary for a COMMON blocks to occur in the caller. It is sufficient that the COMMON block used in a called subroutine occurs somewhere in the call chain. As a consequence, it is not generally possible to associate the COMMON block variables in a called subroutine with those of the caller. For example

progam ex1

common /bf2/x
common /bf1/y

call f1

end program ex1

subroutine f1
common /bf1/y1
call f2
end subroutine f1

subroutine f2
common /bf2/x2
end subroutine f2

In this example, x2 in f2 is associated with x in the main program 

progam ex1
call f1(x,y)
end program ex1

subroutine f1(x,y1)
call f2(x)
! ... use y1 ...
end subroutine f1

subroutine f2(x2)
! ... use of x2
end subroutine f2

So the argument for f2 has to be passed via f1 from the main program. Therefore, we need to analyse the code for the call chain paths between disjoint COMMON blocks and pass all arguments via the intervening calls. This also requires checking if the names are unique an renaming if necessary. The result of this analysis is that for every called subroutine, we have a pair consisting of the common block sequence that will become the call arguments, and the common block sequence that will become the dummy arguments. 

2. The actual conversion

To create the call arguments and dummy arguments, we need to identify which variable in the caller sequence matches which in the subroutine call sequence (called the 'local' sequence for brevity). This is complicated by the fact that storage sequences are allowed to overlap, and do not follow the normal type checking rules. For example, the following is acceptable:

! caller
real xc(8),z1c,z2c
complex yc
common  yc,xc,zx

! local
real xl(2),zl(4)
complex yl(3)
common  yl,xl,zl

yl(1) will be associated with yc(1)
yl(2) will be associated with xl(1) and xl(2)
yl(3) will be associated with zl(1) and zl(2)
zl(3) will be associated with z1c
zl(4) will be associated with z2c

Furthermore, we need to type check the associations, because COMMON blocks are not type safe: the association does not cause type conversion or imply mathematical equivalence. 

XXX algos here XXX




- EQUIVALENCE

According to the F77 spec, 
"An EQUIVALENCE statement is used to specify the sharing of storage units by two or more entities in a program unit. This causes association of the entities that share the storage units.
If the equivalenced entities are of different data types, the EQUIVALENCE statement does not cause type conversion or imply mathematical equivalence. If a variable and an array are equivalenced, the variable does not have array properties and the array does not have the properties of a variable."

This is another form of storage association, with the same issue that it is not type-safe. For example

XXX example XXX

Therefore, EQUIVALENCE statements also need to be refactored. They come with their own flavour of complications. 

if a line has multiple tuples, this is allowed: 

    (v1,v2),(v2,v3)
    
So we must effectively do a transitivity check across all tuples. We do this by checking if an element of a tuple occurs in another tuple. It is sufficient to do this for a single element because the transivity means that every element from the one tuple will be associated with every element from the other.


Furthermore, the tuples (called lists in the spec) can have more than two elements. 

(v1,v2,v3),(v3,v4,v5) 

then this effectively means (v1,v2,v3,v4,v5) and each of these variables is associated with all the others, so there are 10 unique associations in this example. 
In general, for a tuple of n values, there will be (n-1)*n/2 associations.

Another complication is that overlapping is allowed, e.g.:

     DIMENSION RADE11(5), RADE12(5)
     EQUIVALENCE (RADE11(4), RADE12(2))

Because the arrays start at 1, and they overlap, this actually creates an equivalence between `RADE11(3), RADE12(1)` and `RADE11(5), RADE12(3)` as well. So we have to equate the overlapping ranges.





- intent inference (algo)



Because the subroutines to be offloaded cannot contain external calls or I/O calls, we can infer the intent of all arguments by recursive descent into nested calls.



- some discussion on F77 type safety, i.e. F77 warns but errors are blanket
- I need some discussion on EQUIVALENCE too to justify expected behaviour
As it turns out, EQUIVALENCE behaves just like COMMON!
- Need to discuss removal of COMMON blocks
     
- Eliminating SAVE:

• Create a new COMMON block SAVE_$subname
• Add all SAVEd variables from $subname to that block 
• Declare them with the $subname prefix at PROGRAM level
• Initialise them, with defaults if required.
• Add the same COMMON block to the $subname declaration, with the un-prefixed variables
• It is now safe to remove SAVE

 


So the main points to formalise:

a pure function take a number of arguments of a given type and returns a single value of a given type:

f : t_1 -> ... -> t_i -> ... -> t_n -> t_r
y = f x_1 ... x_i ... x_n 
The return value y is of type t_r where t_r in general could be (t_{r,1}, ..., t_{r,i}, ..., t_{r,m})

a FORTRAN 77 subroutine can be translated into a pure function as follows: 
- infer the intent (!)
- every InOut argument becomes an (In,Out) tuple
- every read is from the In, every write is to the Out; 



subroutine f(a_1,...,a_i,...,a_n)

T, intent(InOut) :: a_i

(...,a_i,..., ...,l_{i},...) = exp(...,a_i,..., ...,l_{i},...)

end subroutine f

=> 
subroutine f'(a_1,...,a_{i,in},a_{i,out},...,a_n)

T, intent(In) :: a_{i,in}
T, intent(Out) :: a_{i.out}
T :: a_i ! local

a_i = a_{i,in}

(...,a_i,..., ...,l_{i},...) = exp(...,a_i,..., ...,l_{i},...))

a_{i,out} = a_i

end subroutine f'

Let us denote the transformed argument list as a', so ( a_i \in a' | intent(a_i) = InOut ) = empty

Given the `intent`, then we have:

y = ( a_i \in a' | intent(a_i) = Out ) 
a'' = a' \ y

In this way we have identified the function arguments and the function return value. So regardless of the subroutine syntax, with this information it is now a pure function as far as its arguments are concerned.









The typing rule for a pure function is simply

e1: tau1 s : tau1 -> tau2
--------------------------
call s(e1) :: tau2

where tau1 is type consisting of the the tuple of all input types, tau2 is type consisting of the the tuple of all output types.

-----


Function Declaration Typing

Do I need this? because there is fundamentally no difference in the body

subdecl ::= subroutine id_s ( ...,id_in,i : τ_in,i,... ) : (...,id_out,i : τ_out,i, ...) = [exp_1, ...]

where
	exp_i :: = (id_{j}, ...,l_{i},...) = exp(id_{j}, ...,l_{i},...)

G [id2 : τ1] |-- exp : τ2
----------------------------------------------------------
G |-- (subroutine id_s ( id_1 : τ_1, ... ) : τ_r = exp) ok



Program Typing

contextof(decl1 ... decln) = G

G |-- decl1 ok   ...  G |-- decln ok

----------------------------------------------------

|-- decl1 ... decln ok


The judgment (G |-- exp : τ) states that expression exp has type τ in context G. A context G is a finite partial map from identifiers to types. The context "nil" is the empty context. The context G [x : τ] is the same as G except it maps identifier x to τ. The following rules define the expression typing judgement.


https://www.cs.princeton.edu/courses/archive/spring12/cos320/resources/fun_language_definition.html

-------


Now the big question is: given

common id_1 : tau_1, ...
-- G: all values for id_i in the common block

subroutine s () : () 
  common id_{s,1} : tau_{s,1}, ...
  ...
end subroutine

How can we prove that this is the same as 

call s' (id_i | id_s,i in G_s)


-- G: all updated values for id_i in the common block

G: all types for id_i in the common block, G_s: all types for id_s,i in the common block , 
#{tau_i}>= #{tau_s,i}
forall i in , tau_i == tau_s,i => OK, and not just OK but we can type the subroutine as above

----

So at  first, we will assume that an array T, dimension(i,j,...) :: a
is a collection of scalars and that
a(i,j,k) is syntactic sugar for a_ijk. So all arguments can in principle be scalars (in practice of course not)

Then we revisit this and present an algorithm to map this, including reshaping.

a_{i,s}(j) = a_i,j+k or something

-----

Now let's have a look at what we have:

1/ "Do they align?" i,e, 
#{tau_i}>= #{tau_s,i}
forall i, tau_i == tau_s,i and id_i == id_s,i

If they do, the conversion is trivial

2/ If not:

I need to explain about how the arrays can overlap:

xxxxyzzz
uvxxxx--

uvxxxx--
xxxxyzzz

For simplicity I will assume we always prefix the names from local in caller

	elt_local:common_local_seq' = common_local_seq
	(name_local, decl_local, kind_local, dim_local, dimsz_local, lin_idx_local, used_local ) = elt_local
      type_local = declType decl_local
		if (!null common_caller_seq) then 
-- get caller

case (local,caller) of
(Scalar,Scalar) ->
      if type_local == type_caller
      then
          if kind_local == kind_caller 
          then
	        add_var_decl_to_set 'ExGlobArgs' caller
          else  
              error "Can't match scalars with different kinds in call to $f in $caller"
      else
	    if 
		type_caller == "logical" and type_local=="integer"
--		or type_caller == "logical" and type_local=="real" ! this is debatable because the value in the real will be some non-zero number
		or type_caller == "integer" and type_local=="logical"
		or type_caller == "real" and type_local=="logical"
-- and in principle this should be done for different kinds of course, and it should even work for character? Let's not go there.
          error "Types of local and caller are not the same in call to $f in $caller"
(Array,Array) ->  
    if type_local == type_caller 
    then
    if size_local == size_caller 
    then    
        if kind_local == kind_caller 
        then
-- this is fine, matching array
            add_var_decl_to_set 'ExGlobArgs' caller
            equiv_pair  ( local, dim_local_copy ),(caller, dim_caller_copy ) 
        else if kind_local > kind_caller then
-- this means that we are grouping kind_local/kind_caller values from the caller into each local
-- this I think should be an error 
        else -- kind_local < kind_caller
-- this means that we are mapping each value from the caller onto kind_caller/kind_local locals
-- this I think should be an error
-- so we should lift this up!
    else
        -- The arrays are not the same size, 
        if size_local > size_caller 
        then -- the caller array can be entirely mapped onto the local array
            add_var_decl_to_set 'ExGlobArgs' caller
            equiv_pair  ( local, dim_local_copy ),(caller, dim_caller_copy )
        else -- the caller array cannot be entirely mapped onto the local array
            add_var_decl_to_set 'ExGlobArgs' caller
            equiv_pair  ( local, dim_local_copy ),(caller, dim_caller_copy )
    else
        if type_local == "real" and type_caller == "complex"
        then
-- if the sizes match, we accept that
        else if type_local == "complex" and type_caller == "real"
        then
-- if the sizes match, we accept that
        else
            error "Types of local and caller don't match"
(Array, Scalar) ->
    if type_local == type_caller 
    then
    if kind_local == kind_caller 
    then
        add_var_decl_to_set 'ExGlobArgs' caller
        equiv_pair  ( local, dim_local_copy ),(caller, [] ) 
    else
        error "Can't match a scalar to an array with different kinds in call to $f in $caller"		
    else
	  if  type_local == 'real' and size_local==2 and rank_local==1 and type_caller==complex
	  then
	  else
		error "Types of local and caller are not compatible in call to $f in $caller"
(Scalar, Array) ->
    if type_local == type_caller
    then
    if kind_local == kind_caller 
    then
        add_var_decl_to_set 'ExGlobArgs' caller
        equiv_pair  ( local, [] ),(caller, dim_caller_copy ) 
    else
        error "Can't match a scalar to an array with different kinds in call to $f in $caller"
    else
	  if  type_local=="complex" and type_caller == 'real' and size_caller==2 and rank_caller==1 
	  then
		
	  else
		error "Types of local and caller are not compatible in call to $f in $caller"

else
    error "Local common block sequence can't be longer than caller common block sequence"


====


data Array a = MkArray
    atype :: TypeName, -- some representation of the name of the type a
    adim :: [(Int,Int)], -- can calculate size and rank from this
    avals :: [a]

type Array
  sequence
  TypeName :: atype,
  integer, dimension(arank,2) :: adim
  a, dimension(asize) :: avals
  
  
